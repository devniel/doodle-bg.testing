/* tslint:disable */
/* eslint-disable */
/**
 * FastAPI
 * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)
 *
 * The version of the OpenAPI document: 0.1.0
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import type { Configuration } from './configuration';
import type { AxiosPromise, AxiosInstance, RawAxiosRequestConfig } from 'axios';
import globalAxios from 'axios';
// Some imports not used depending on template conditions
// @ts-ignore
import { DUMMY_BASE_URL, assertParamExists, setApiKeyToObject, setBasicAuthToObject, setBearerAuthToObject, setOAuthToObject, setSearchParams, serializeDataIfNeeded, toPathString, createRequestFunction } from './common';
import type { RequestArgs } from './base';
// @ts-ignore
import { BASE_PATH, COLLECTION_FORMATS, BaseAPI, RequiredError, operationServerMap } from './base';

/**
 * 
 * @export
 * @interface CreateResponse
 */
export interface CreateResponse {
    /**
     * Response string from create embedding or hypernetwork task.
     * @type {string}
     * @memberof CreateResponse
     */
    'info': string;
}
/**
 * 
 * @export
 * @interface EmbeddingItem
 */
export interface EmbeddingItem {
    /**
     * The number of steps that were used to train this embedding, if available
     * @type {number}
     * @memberof EmbeddingItem
     */
    'step'?: number;
    /**
     * The hash of the checkpoint this embedding was trained on, if available
     * @type {string}
     * @memberof EmbeddingItem
     */
    'sd_checkpoint'?: string;
    /**
     * The name of the checkpoint this embedding was trained on, if available. Note that this is the name that was used by the trainer; for a stable identifier, use `sd_checkpoint` instead
     * @type {string}
     * @memberof EmbeddingItem
     */
    'sd_checkpoint_name'?: string;
    /**
     * The length of each individual vector in the embedding
     * @type {number}
     * @memberof EmbeddingItem
     */
    'shape': number;
    /**
     * The number of vectors in the embedding
     * @type {number}
     * @memberof EmbeddingItem
     */
    'vectors': number;
}
/**
 * 
 * @export
 * @interface EmbeddingsResponse
 */
export interface EmbeddingsResponse {
    /**
     * Embeddings loaded for the current model
     * @type {{ [key: string]: EmbeddingItem; }}
     * @memberof EmbeddingsResponse
     */
    'loaded': { [key: string]: EmbeddingItem; };
    /**
     * Embeddings skipped for the current model (likely due to architecture incompatibility)
     * @type {{ [key: string]: EmbeddingItem; }}
     * @memberof EmbeddingsResponse
     */
    'skipped': { [key: string]: EmbeddingItem; };
}
/**
 * 
 * @export
 * @interface Estimation
 */
export interface Estimation {
    /**
     * 
     * @type {string}
     * @memberof Estimation
     */
    'msg'?: string;
    /**
     * 
     * @type {number}
     * @memberof Estimation
     */
    'rank'?: number;
    /**
     * 
     * @type {number}
     * @memberof Estimation
     */
    'queue_size': number;
    /**
     * 
     * @type {number}
     * @memberof Estimation
     */
    'avg_event_process_time'?: number;
    /**
     * 
     * @type {number}
     * @memberof Estimation
     */
    'avg_event_concurrent_process_time'?: number;
    /**
     * 
     * @type {number}
     * @memberof Estimation
     */
    'rank_eta'?: number;
    /**
     * 
     * @type {number}
     * @memberof Estimation
     */
    'queue_eta': number;
}
/**
 * 
 * @export
 * @interface ExtensionItem
 */
export interface ExtensionItem {
    /**
     * Extension name
     * @type {string}
     * @memberof ExtensionItem
     */
    'name': string;
    /**
     * Extension Repository URL
     * @type {string}
     * @memberof ExtensionItem
     */
    'remote': string;
    /**
     * Extension Repository Branch
     * @type {string}
     * @memberof ExtensionItem
     */
    'branch': string;
    /**
     * Extension Repository Commit Hash
     * @type {string}
     * @memberof ExtensionItem
     */
    'commit_hash': string;
    /**
     * Extension Version
     * @type {string}
     * @memberof ExtensionItem
     */
    'version': string;
    /**
     * Extension Repository Commit Date
     * @type {string}
     * @memberof ExtensionItem
     */
    'commit_date': string;
    /**
     * Flag specifying whether this extension is enabled
     * @type {boolean}
     * @memberof ExtensionItem
     */
    'enabled': boolean;
}
/**
 * 
 * @export
 * @interface ExtrasBatchImagesRequest
 */
export interface ExtrasBatchImagesRequest {
    /**
     * Sets the resize mode: 0 to upscale by upscaling_resize amount, 1 to upscale up to upscaling_resize_h x upscaling_resize_w.
     * @type {number}
     * @memberof ExtrasBatchImagesRequest
     */
    'resize_mode'?: ExtrasBatchImagesRequestResizeModeEnum;
    /**
     * Should the backend return the generated image?
     * @type {boolean}
     * @memberof ExtrasBatchImagesRequest
     */
    'show_extras_results'?: boolean;
    /**
     * Sets the visibility of GFPGAN, values should be between 0 and 1.
     * @type {number}
     * @memberof ExtrasBatchImagesRequest
     */
    'gfpgan_visibility'?: number;
    /**
     * Sets the visibility of CodeFormer, values should be between 0 and 1.
     * @type {number}
     * @memberof ExtrasBatchImagesRequest
     */
    'codeformer_visibility'?: number;
    /**
     * Sets the weight of CodeFormer, values should be between 0 and 1.
     * @type {number}
     * @memberof ExtrasBatchImagesRequest
     */
    'codeformer_weight'?: number;
    /**
     * By how much to upscale the image, only used when resize_mode=0.
     * @type {number}
     * @memberof ExtrasBatchImagesRequest
     */
    'upscaling_resize'?: number;
    /**
     * Target width for the upscaler to hit. Only used when resize_mode=1.
     * @type {number}
     * @memberof ExtrasBatchImagesRequest
     */
    'upscaling_resize_w'?: number;
    /**
     * Target height for the upscaler to hit. Only used when resize_mode=1.
     * @type {number}
     * @memberof ExtrasBatchImagesRequest
     */
    'upscaling_resize_h'?: number;
    /**
     * Should the upscaler crop the image to fit in the chosen size?
     * @type {boolean}
     * @memberof ExtrasBatchImagesRequest
     */
    'upscaling_crop'?: boolean;
    /**
     * The name of the main upscaler to use, it has to be one of this list: None , Lanczos , Nearest , ESRGAN_4x , LDSR , R-ESRGAN 4x+ , R-ESRGAN 4x+ Anime6B , ScuNET GAN , ScuNET PSNR , SwinIR 4x
     * @type {string}
     * @memberof ExtrasBatchImagesRequest
     */
    'upscaler_1'?: string;
    /**
     * The name of the secondary upscaler to use, it has to be one of this list: None , Lanczos , Nearest , ESRGAN_4x , LDSR , R-ESRGAN 4x+ , R-ESRGAN 4x+ Anime6B , ScuNET GAN , ScuNET PSNR , SwinIR 4x
     * @type {string}
     * @memberof ExtrasBatchImagesRequest
     */
    'upscaler_2'?: string;
    /**
     * Sets the visibility of secondary upscaler, values should be between 0 and 1.
     * @type {number}
     * @memberof ExtrasBatchImagesRequest
     */
    'extras_upscaler_2_visibility'?: number;
    /**
     * Should the upscaler run before restoring faces?
     * @type {boolean}
     * @memberof ExtrasBatchImagesRequest
     */
    'upscale_first'?: boolean;
    /**
     * List of images to work on. Must be Base64 strings
     * @type {Array<FileData>}
     * @memberof ExtrasBatchImagesRequest
     */
    'imageList': Array<FileData>;
}

export const ExtrasBatchImagesRequestResizeModeEnum = {
    NUMBER_0: 0,
    NUMBER_1: 1
} as const;

export type ExtrasBatchImagesRequestResizeModeEnum = typeof ExtrasBatchImagesRequestResizeModeEnum[keyof typeof ExtrasBatchImagesRequestResizeModeEnum];

/**
 * 
 * @export
 * @interface ExtrasBatchImagesResponse
 */
export interface ExtrasBatchImagesResponse {
    /**
     * A series of HTML tags containing the process info.
     * @type {string}
     * @memberof ExtrasBatchImagesResponse
     */
    'html_info': string;
    /**
     * The generated images in base64 format.
     * @type {Array<string>}
     * @memberof ExtrasBatchImagesResponse
     */
    'images': Array<string>;
}
/**
 * 
 * @export
 * @interface ExtrasSingleImageRequest
 */
export interface ExtrasSingleImageRequest {
    /**
     * Sets the resize mode: 0 to upscale by upscaling_resize amount, 1 to upscale up to upscaling_resize_h x upscaling_resize_w.
     * @type {number}
     * @memberof ExtrasSingleImageRequest
     */
    'resize_mode'?: ExtrasSingleImageRequestResizeModeEnum;
    /**
     * Should the backend return the generated image?
     * @type {boolean}
     * @memberof ExtrasSingleImageRequest
     */
    'show_extras_results'?: boolean;
    /**
     * Sets the visibility of GFPGAN, values should be between 0 and 1.
     * @type {number}
     * @memberof ExtrasSingleImageRequest
     */
    'gfpgan_visibility'?: number;
    /**
     * Sets the visibility of CodeFormer, values should be between 0 and 1.
     * @type {number}
     * @memberof ExtrasSingleImageRequest
     */
    'codeformer_visibility'?: number;
    /**
     * Sets the weight of CodeFormer, values should be between 0 and 1.
     * @type {number}
     * @memberof ExtrasSingleImageRequest
     */
    'codeformer_weight'?: number;
    /**
     * By how much to upscale the image, only used when resize_mode=0.
     * @type {number}
     * @memberof ExtrasSingleImageRequest
     */
    'upscaling_resize'?: number;
    /**
     * Target width for the upscaler to hit. Only used when resize_mode=1.
     * @type {number}
     * @memberof ExtrasSingleImageRequest
     */
    'upscaling_resize_w'?: number;
    /**
     * Target height for the upscaler to hit. Only used when resize_mode=1.
     * @type {number}
     * @memberof ExtrasSingleImageRequest
     */
    'upscaling_resize_h'?: number;
    /**
     * Should the upscaler crop the image to fit in the chosen size?
     * @type {boolean}
     * @memberof ExtrasSingleImageRequest
     */
    'upscaling_crop'?: boolean;
    /**
     * The name of the main upscaler to use, it has to be one of this list: None , Lanczos , Nearest , ESRGAN_4x , LDSR , R-ESRGAN 4x+ , R-ESRGAN 4x+ Anime6B , ScuNET GAN , ScuNET PSNR , SwinIR 4x
     * @type {string}
     * @memberof ExtrasSingleImageRequest
     */
    'upscaler_1'?: string;
    /**
     * The name of the secondary upscaler to use, it has to be one of this list: None , Lanczos , Nearest , ESRGAN_4x , LDSR , R-ESRGAN 4x+ , R-ESRGAN 4x+ Anime6B , ScuNET GAN , ScuNET PSNR , SwinIR 4x
     * @type {string}
     * @memberof ExtrasSingleImageRequest
     */
    'upscaler_2'?: string;
    /**
     * Sets the visibility of secondary upscaler, values should be between 0 and 1.
     * @type {number}
     * @memberof ExtrasSingleImageRequest
     */
    'extras_upscaler_2_visibility'?: number;
    /**
     * Should the upscaler run before restoring faces?
     * @type {boolean}
     * @memberof ExtrasSingleImageRequest
     */
    'upscale_first'?: boolean;
    /**
     * Image to work on, must be a Base64 string containing the image\'s data.
     * @type {string}
     * @memberof ExtrasSingleImageRequest
     */
    'image'?: string;
}

export const ExtrasSingleImageRequestResizeModeEnum = {
    NUMBER_0: 0,
    NUMBER_1: 1
} as const;

export type ExtrasSingleImageRequestResizeModeEnum = typeof ExtrasSingleImageRequestResizeModeEnum[keyof typeof ExtrasSingleImageRequestResizeModeEnum];

/**
 * 
 * @export
 * @interface ExtrasSingleImageResponse
 */
export interface ExtrasSingleImageResponse {
    /**
     * A series of HTML tags containing the process info.
     * @type {string}
     * @memberof ExtrasSingleImageResponse
     */
    'html_info': string;
    /**
     * The generated image in base64 format.
     * @type {string}
     * @memberof ExtrasSingleImageResponse
     */
    'image'?: string;
}
/**
 * 
 * @export
 * @interface FaceRestorerItem
 */
export interface FaceRestorerItem {
    /**
     * 
     * @type {string}
     * @memberof FaceRestorerItem
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof FaceRestorerItem
     */
    'cmd_dir'?: string;
}
/**
 * 
 * @export
 * @interface FileData
 */
export interface FileData {
    /**
     * Base64 representation of the file
     * @type {string}
     * @memberof FileData
     */
    'data': string;
    /**
     * 
     * @type {string}
     * @memberof FileData
     */
    'name': string;
}
/**
 * 
 * @export
 * @interface Flags
 */
export interface Flags {
    /**
     * ==SUPPRESS==
     * @type {boolean}
     * @memberof Flags
     */
    'f'?: boolean;
    /**
     * launch.py argument: download updates for all extensions when starting the program
     * @type {boolean}
     * @memberof Flags
     */
    'update_all_extensions'?: boolean;
    /**
     * launch.py argument: do not check python version
     * @type {boolean}
     * @memberof Flags
     */
    'skip_python_version_check'?: boolean;
    /**
     * launch.py argument: do not check if CUDA is able to work properly
     * @type {boolean}
     * @memberof Flags
     */
    'skip_torch_cuda_test'?: boolean;
    /**
     * launch.py argument: install the appropriate version of xformers even if you have some version already installed
     * @type {boolean}
     * @memberof Flags
     */
    'reinstall_xformers'?: boolean;
    /**
     * launch.py argument: install the appropriate version of torch even if you have some version already installed
     * @type {boolean}
     * @memberof Flags
     */
    'reinstall_torch'?: boolean;
    /**
     * launch.py argument: check for updates at startup
     * @type {boolean}
     * @memberof Flags
     */
    'update_check'?: boolean;
    /**
     * launch.py argument: configure server for testing
     * @type {boolean}
     * @memberof Flags
     */
    'test_server'?: boolean;
    /**
     * launch.py argument: print a detailed log of what\'s happening at startup
     * @type {boolean}
     * @memberof Flags
     */
    'log_startup'?: boolean;
    /**
     * launch.py argument: skip all environment preparation
     * @type {boolean}
     * @memberof Flags
     */
    'skip_prepare_environment'?: boolean;
    /**
     * launch.py argument: skip installation of packages
     * @type {boolean}
     * @memberof Flags
     */
    'skip_install'?: boolean;
    /**
     * launch.py argument: dump limited sysinfo file (without information about extensions, options) to disk and quit
     * @type {boolean}
     * @memberof Flags
     */
    'dump_sysinfo'?: boolean;
    /**
     * log level; one of: CRITICAL, ERROR, WARNING, INFO, DEBUG
     * @type {string}
     * @memberof Flags
     */
    'loglevel'?: string;
    /**
     * do not download CLIP model even if it\'s not included in the checkpoint
     * @type {boolean}
     * @memberof Flags
     */
    'do_not_download_clip'?: boolean;
    /**
     * base path where all user data is stored
     * @type {string}
     * @memberof Flags
     */
    'data_dir'?: string;
    /**
     * path to config which constructs model
     * @type {string}
     * @memberof Flags
     */
    'config'?: string;
    /**
     * path to checkpoint of stable diffusion model; if specified, this checkpoint will be added to the list of checkpoints and loaded
     * @type {string}
     * @memberof Flags
     */
    'ckpt'?: string;
    /**
     * Path to directory with stable diffusion checkpoints
     * @type {string}
     * @memberof Flags
     */
    'ckpt_dir'?: string;
    /**
     * Path to directory with VAE files
     * @type {string}
     * @memberof Flags
     */
    'vae_dir'?: string;
    /**
     * GFPGAN directory
     * @type {string}
     * @memberof Flags
     */
    'gfpgan_dir'?: string;
    /**
     * GFPGAN model file name
     * @type {string}
     * @memberof Flags
     */
    'gfpgan_model'?: string;
    /**
     * do not switch the model to 16-bit floats
     * @type {boolean}
     * @memberof Flags
     */
    'no_half'?: boolean;
    /**
     * do not switch the VAE model to 16-bit floats
     * @type {boolean}
     * @memberof Flags
     */
    'no_half_vae'?: boolean;
    /**
     * do not hide progressbar in gradio UI (we hide it because it slows down ML if you have hardware acceleration in browser)
     * @type {boolean}
     * @memberof Flags
     */
    'no_progressbar_hiding'?: boolean;
    /**
     * maximum batch count value for the UI
     * @type {number}
     * @memberof Flags
     */
    'max_batch_count'?: number;
    /**
     * embeddings directory for textual inversion (default: embeddings)
     * @type {string}
     * @memberof Flags
     */
    'embeddings_dir'?: string;
    /**
     * directory with textual inversion templates
     * @type {string}
     * @memberof Flags
     */
    'textual_inversion_templates_dir'?: string;
    /**
     * hypernetwork directory
     * @type {string}
     * @memberof Flags
     */
    'hypernetwork_dir'?: string;
    /**
     * localizations directory
     * @type {string}
     * @memberof Flags
     */
    'localizations_dir'?: string;
    /**
     * allow custom script execution from webui
     * @type {boolean}
     * @memberof Flags
     */
    'allow_code'?: boolean;
    /**
     * enable stable diffusion model optimizations for sacrificing a little speed for low VRM usage
     * @type {boolean}
     * @memberof Flags
     */
    'medvram'?: boolean;
    /**
     * enable --medvram optimization just for SDXL models
     * @type {boolean}
     * @memberof Flags
     */
    'medvram_sdxl'?: boolean;
    /**
     * enable stable diffusion model optimizations for sacrificing a lot of speed for very low VRM usage
     * @type {boolean}
     * @memberof Flags
     */
    'lowvram'?: boolean;
    /**
     * load stable diffusion checkpoint weights to VRAM instead of RAM
     * @type {boolean}
     * @memberof Flags
     */
    'lowram'?: boolean;
    /**
     * does not do anything
     * @type {boolean}
     * @memberof Flags
     */
    'always_batch_cond_uncond'?: boolean;
    /**
     * does not do anything.
     * @type {boolean}
     * @memberof Flags
     */
    'unload_gfpgan'?: boolean;
    /**
     * evaluate at this precision
     * @type {string}
     * @memberof Flags
     */
    'precision'?: string;
    /**
     * upcast sampling. No effect with --no-half. Usually produces similar results to --no-half with better performance while using less memory.
     * @type {boolean}
     * @memberof Flags
     */
    'upcast_sampling'?: boolean;
    /**
     * use share=True for gradio and make the UI accessible through their site
     * @type {boolean}
     * @memberof Flags
     */
    'share'?: boolean;
    /**
     * ngrok authtoken, alternative to gradio --share
     * @type {string}
     * @memberof Flags
     */
    'ngrok'?: string;
    /**
     * does not do anything.
     * @type {string}
     * @memberof Flags
     */
    'ngrok_region'?: string;
    /**
     * The options to pass to ngrok in JSON format, e.g.: \'{\"authtoken_from_env\":true, \"basic_auth\":\"user:password\", \"oauth_provider\":\"google\", \"oauth_allow_emails\":\"user@asdf.com\"}\'
     * @type {object}
     * @memberof Flags
     */
    'ngrok_options'?: object;
    /**
     * enable extensions tab regardless of other options
     * @type {boolean}
     * @memberof Flags
     */
    'enable_insecure_extension_access'?: boolean;
    /**
     * Path to directory with codeformer model file(s).
     * @type {string}
     * @memberof Flags
     */
    'codeformer_models_path'?: string;
    /**
     * Path to directory with GFPGAN model file(s).
     * @type {string}
     * @memberof Flags
     */
    'gfpgan_models_path'?: string;
    /**
     * Path to directory with ESRGAN model file(s).
     * @type {string}
     * @memberof Flags
     */
    'esrgan_models_path'?: string;
    /**
     * Path to directory with BSRGAN model file(s).
     * @type {string}
     * @memberof Flags
     */
    'bsrgan_models_path'?: string;
    /**
     * Path to directory with RealESRGAN model file(s).
     * @type {string}
     * @memberof Flags
     */
    'realesrgan_models_path'?: string;
    /**
     * Path to directory with CLIP model file(s).
     * @type {string}
     * @memberof Flags
     */
    'clip_models_path'?: string;
    /**
     * enable xformers for cross attention layers
     * @type {boolean}
     * @memberof Flags
     */
    'xformers'?: boolean;
    /**
     * enable xformers for cross attention layers regardless of whether the checking code thinks you can run it; do not make bug reports if this fails to work
     * @type {boolean}
     * @memberof Flags
     */
    'force_enable_xformers'?: boolean;
    /**
     * enable xformers with Flash Attention to improve reproducibility (supported for SD2.x or variant only)
     * @type {boolean}
     * @memberof Flags
     */
    'xformers_flash_attention'?: boolean;
    /**
     * does not do anything
     * @type {boolean}
     * @memberof Flags
     */
    'deepdanbooru'?: boolean;
    /**
     * prefer Doggettx\'s cross-attention layer optimization for automatic choice of optimization
     * @type {boolean}
     * @memberof Flags
     */
    'opt_split_attention'?: boolean;
    /**
     * prefer memory efficient sub-quadratic cross-attention layer optimization for automatic choice of optimization
     * @type {boolean}
     * @memberof Flags
     */
    'opt_sub_quad_attention'?: boolean;
    /**
     * query chunk size for the sub-quadratic cross-attention layer optimization to use
     * @type {number}
     * @memberof Flags
     */
    'sub_quad_q_chunk_size'?: number;
    /**
     * kv chunk size for the sub-quadratic cross-attention layer optimization to use
     * @type {string}
     * @memberof Flags
     */
    'sub_quad_kv_chunk_size'?: string;
    /**
     * the percentage of VRAM threshold for the sub-quadratic cross-attention layer optimization to use chunking
     * @type {string}
     * @memberof Flags
     */
    'sub_quad_chunk_threshold'?: string;
    /**
     * prefer InvokeAI\'s cross-attention layer optimization for automatic choice of optimization
     * @type {boolean}
     * @memberof Flags
     */
    'opt_split_attention_invokeai'?: boolean;
    /**
     * prefer older version of split attention optimization for automatic choice of optimization
     * @type {boolean}
     * @memberof Flags
     */
    'opt_split_attention_v1'?: boolean;
    /**
     * prefer scaled dot product cross-attention layer optimization for automatic choice of optimization; requires PyTorch 2.*
     * @type {boolean}
     * @memberof Flags
     */
    'opt_sdp_attention'?: boolean;
    /**
     * prefer scaled dot product cross-attention layer optimization without memory efficient attention for automatic choice of optimization, makes image generation deterministic; requires PyTorch 2.*
     * @type {boolean}
     * @memberof Flags
     */
    'opt_sdp_no_mem_attention'?: boolean;
    /**
     * prefer no cross-attention layer optimization for automatic choice of optimization
     * @type {boolean}
     * @memberof Flags
     */
    'disable_opt_split_attention'?: boolean;
    /**
     * do not check if produced images/latent spaces have nans; useful for running without a checkpoint in CI
     * @type {boolean}
     * @memberof Flags
     */
    'disable_nan_check'?: boolean;
    /**
     * use CPU as torch device for specified modules
     * @type {Array<any>}
     * @memberof Flags
     */
    'use_cpu'?: Array<any>;
    /**
     * use Intel XPU as torch device
     * @type {boolean}
     * @memberof Flags
     */
    'use_ipex'?: boolean;
    /**
     * disable an optimization that reduces RAM use when loading a model
     * @type {boolean}
     * @memberof Flags
     */
    'disable_model_loading_ram_optimization'?: boolean;
    /**
     * launch gradio with 0.0.0.0 as server name, allowing to respond to network requests
     * @type {boolean}
     * @memberof Flags
     */
    'listen'?: boolean;
    /**
     * launch gradio with given server port, you need root/admin rights for ports < 1024, defaults to 7860 if available
     * @type {string}
     * @memberof Flags
     */
    'port'?: string;
    /**
     * does not do anything
     * @type {boolean}
     * @memberof Flags
     */
    'show_negative_prompt'?: boolean;
    /**
     * filename to use for ui configuration
     * @type {string}
     * @memberof Flags
     */
    'ui_config_file'?: string;
    /**
     * hide directory configuration from webui
     * @type {boolean}
     * @memberof Flags
     */
    'hide_ui_dir_config'?: boolean;
    /**
     * disable editing settings
     * @type {boolean}
     * @memberof Flags
     */
    'freeze_settings'?: boolean;
    /**
     * filename to use for ui settings
     * @type {string}
     * @memberof Flags
     */
    'ui_settings_file'?: string;
    /**
     * launch gradio with --debug option
     * @type {boolean}
     * @memberof Flags
     */
    'gradio_debug'?: boolean;
    /**
     * set gradio authentication like \"username:password\"; or comma-delimit multiple like \"u1:p1,u2:p2,u3:p3\"
     * @type {string}
     * @memberof Flags
     */
    'gradio_auth'?: string;
    /**
     * set gradio authentication file path ex. \"/path/to/auth/file\" same auth format as --gradio-auth
     * @type {string}
     * @memberof Flags
     */
    'gradio_auth_path'?: string;
    /**
     * does not do anything
     * @type {string}
     * @memberof Flags
     */
    'gradio_img2img_tool'?: string;
    /**
     * does not do anything
     * @type {string}
     * @memberof Flags
     */
    'gradio_inpaint_tool'?: string;
    /**
     * add path to gradio\'s allowed_paths, make it possible to serve files from it
     * @type {Array<any>}
     * @memberof Flags
     */
    'gradio_allowed_path'?: Array<any>;
    /**
     * change memory type for stable diffusion to channels last
     * @type {boolean}
     * @memberof Flags
     */
    'opt_channelslast'?: boolean;
    /**
     * filename to use for styles
     * @type {string}
     * @memberof Flags
     */
    'styles_file'?: string;
    /**
     * open the webui URL in the system\'s default browser upon launch
     * @type {boolean}
     * @memberof Flags
     */
    'autolaunch'?: boolean;
    /**
     * launches the UI with light or dark theme
     * @type {string}
     * @memberof Flags
     */
    'theme'?: string;
    /**
     * use textbox for seeds in UI (no up/down, but possible to input long seeds)
     * @type {boolean}
     * @memberof Flags
     */
    'use_textbox_seed'?: boolean;
    /**
     * do not output progressbars to console
     * @type {boolean}
     * @memberof Flags
     */
    'disable_console_progressbars'?: boolean;
    /**
     * does not do anything
     * @type {boolean}
     * @memberof Flags
     */
    'enable_console_prompts'?: boolean;
    /**
     * Checkpoint to use as VAE; setting this argument disables all settings related to VAE
     * @type {string}
     * @memberof Flags
     */
    'vae_path'?: string;
    /**
     * disable checking pytorch models for malicious code
     * @type {boolean}
     * @memberof Flags
     */
    'disable_safe_unpickle'?: boolean;
    /**
     * use api=True to launch the API together with the webui (use --nowebui instead for only the API)
     * @type {boolean}
     * @memberof Flags
     */
    'api'?: boolean;
    /**
     * Set authentication for API like \"username:password\"; or comma-delimit multiple like \"u1:p1,u2:p2,u3:p3\"
     * @type {string}
     * @memberof Flags
     */
    'api_auth'?: string;
    /**
     * use api-log=True to enable logging of all API requests
     * @type {boolean}
     * @memberof Flags
     */
    'api_log'?: boolean;
    /**
     * use api=True to launch the API instead of the webui
     * @type {boolean}
     * @memberof Flags
     */
    'nowebui'?: boolean;
    /**
     * Don\'t load model to quickly launch UI
     * @type {boolean}
     * @memberof Flags
     */
    'ui_debug_mode'?: boolean;
    /**
     * Select the default CUDA device to use (export CUDA_VISIBLE_DEVICES=0,1,etc might be needed before)
     * @type {string}
     * @memberof Flags
     */
    'device_id'?: string;
    /**
     * Administrator rights
     * @type {boolean}
     * @memberof Flags
     */
    'administrator'?: boolean;
    /**
     * Allowed CORS origin(s) in the form of a comma-separated list (no spaces)
     * @type {string}
     * @memberof Flags
     */
    'cors_allow_origins'?: string;
    /**
     * Allowed CORS origin(s) in the form of a single regular expression
     * @type {string}
     * @memberof Flags
     */
    'cors_allow_origins_regex'?: string;
    /**
     * Partially enables TLS, requires --tls-certfile to fully function
     * @type {string}
     * @memberof Flags
     */
    'tls_keyfile'?: string;
    /**
     * Partially enables TLS, requires --tls-keyfile to fully function
     * @type {string}
     * @memberof Flags
     */
    'tls_certfile'?: string;
    /**
     * When passed, enables the use of self-signed certificates.
     * @type {string}
     * @memberof Flags
     */
    'disable_tls_verify'?: string;
    /**
     * Sets hostname of server
     * @type {string}
     * @memberof Flags
     */
    'server_name'?: string;
    /**
     * does not do anything
     * @type {boolean}
     * @memberof Flags
     */
    'gradio_queue'?: boolean;
    /**
     * Disables gradio queue; causes the webpage to use http requests instead of websockets; was the default in earlier versions
     * @type {boolean}
     * @memberof Flags
     */
    'no_gradio_queue'?: boolean;
    /**
     * Do not check versions of torch and xformers
     * @type {boolean}
     * @memberof Flags
     */
    'skip_version_check'?: boolean;
    /**
     * disable sha256 hashing of checkpoints to help loading performance
     * @type {boolean}
     * @memberof Flags
     */
    'no_hashing'?: boolean;
    /**
     * don\'t download SD1.5 model even if no model is found in --ckpt-dir
     * @type {boolean}
     * @memberof Flags
     */
    'no_download_sd_model'?: boolean;
    /**
     * customize the subpath for gradio, use with reverse proxy
     * @type {string}
     * @memberof Flags
     */
    'subpath'?: string;
    /**
     * does not do anything
     * @type {boolean}
     * @memberof Flags
     */
    'add_stop_route'?: boolean;
    /**
     * enable server stop/restart/kill via api
     * @type {boolean}
     * @memberof Flags
     */
    'api_server_stop'?: boolean;
    /**
     * set timeout_keep_alive for uvicorn
     * @type {number}
     * @memberof Flags
     */
    'timeout_keep_alive'?: number;
    /**
     * prevent all extensions from running regardless of any other settings
     * @type {boolean}
     * @memberof Flags
     */
    'disable_all_extensions'?: boolean;
    /**
     * prevent all extensions except built-in from running regardless of any other settings
     * @type {boolean}
     * @memberof Flags
     */
    'disable_extra_extensions'?: boolean;
    /**
     * if load a model at web start, only take effect when --nowebui
     * @type {boolean}
     * @memberof Flags
     */
    'skip_load_model_at_start'?: boolean;
    /**
     * Path to directory with LDSR model file(s).
     * @type {string}
     * @memberof Flags
     */
    'ldsr_models_path'?: string;
    /**
     * Path to directory with Lora networks.
     * @type {string}
     * @memberof Flags
     */
    'lora_dir'?: string;
    /**
     * Path to directory with LyCORIS networks (for backawards compatibility; can also use --lyco-dir).
     * @type {string}
     * @memberof Flags
     */
    'lyco_dir_backcompat'?: string;
    /**
     * Path to directory with ScuNET model file(s).
     * @type {string}
     * @memberof Flags
     */
    'scunet_models_path'?: string;
    /**
     * Path to directory with SwinIR model file(s).
     * @type {string}
     * @memberof Flags
     */
    'swinir_models_path'?: string;
}
/**
 * 
 * @export
 * @interface HTTPValidationError
 */
export interface HTTPValidationError {
    /**
     * 
     * @type {Array<ValidationError>}
     * @memberof HTTPValidationError
     */
    'detail'?: Array<ValidationError>;
}
/**
 * 
 * @export
 * @interface HypernetworkItem
 */
export interface HypernetworkItem {
    /**
     * 
     * @type {string}
     * @memberof HypernetworkItem
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof HypernetworkItem
     */
    'path'?: string;
}
/**
 * 
 * @export
 * @interface ImageToImageResponse
 */
export interface ImageToImageResponse {
    /**
     * The generated image in base64 format.
     * @type {Array<string>}
     * @memberof ImageToImageResponse
     */
    'images'?: Array<string>;
    /**
     * 
     * @type {object}
     * @memberof ImageToImageResponse
     */
    'parameters': object;
    /**
     * 
     * @type {string}
     * @memberof ImageToImageResponse
     */
    'info': string;
}
/**
 * 
 * @export
 * @interface InterrogateRequest
 */
export interface InterrogateRequest {
    /**
     * Image to work on, must be a Base64 string containing the image\'s data.
     * @type {string}
     * @memberof InterrogateRequest
     */
    'image'?: string;
    /**
     * The interrogate model used.
     * @type {string}
     * @memberof InterrogateRequest
     */
    'model'?: string;
}
/**
 * 
 * @export
 * @interface LatentUpscalerModeItem
 */
export interface LatentUpscalerModeItem {
    /**
     * 
     * @type {string}
     * @memberof LatentUpscalerModeItem
     */
    'name': string;
}
/**
 * 
 * @export
 * @interface LocationInner
 */
export interface LocationInner {
}
/**
 * 
 * @export
 * @interface MemoryResponse
 */
export interface MemoryResponse {
    /**
     * System memory stats
     * @type {object}
     * @memberof MemoryResponse
     */
    'ram': object;
    /**
     * nVidia CUDA memory stats
     * @type {object}
     * @memberof MemoryResponse
     */
    'cuda': object;
}
/**
 * 
 * @export
 * @interface ModulesApiModelsProgressResponse
 */
export interface ModulesApiModelsProgressResponse {
    /**
     * The progress with a range of 0 to 1
     * @type {number}
     * @memberof ModulesApiModelsProgressResponse
     */
    'progress': number;
    /**
     * 
     * @type {number}
     * @memberof ModulesApiModelsProgressResponse
     */
    'eta_relative': number;
    /**
     * The current state snapshot
     * @type {object}
     * @memberof ModulesApiModelsProgressResponse
     */
    'state': object;
    /**
     * The current image in base64 format. opts.show_progress_every_n_steps is required for this to work.
     * @type {string}
     * @memberof ModulesApiModelsProgressResponse
     */
    'current_image'?: string;
    /**
     * Info text used by WebUI.
     * @type {string}
     * @memberof ModulesApiModelsProgressResponse
     */
    'textinfo'?: string;
}
/**
 * 
 * @export
 * @interface ModulesProgressProgressResponse
 */
export interface ModulesProgressProgressResponse {
    /**
     * 
     * @type {boolean}
     * @memberof ModulesProgressProgressResponse
     */
    'active': boolean;
    /**
     * 
     * @type {boolean}
     * @memberof ModulesProgressProgressResponse
     */
    'queued': boolean;
    /**
     * 
     * @type {boolean}
     * @memberof ModulesProgressProgressResponse
     */
    'completed': boolean;
    /**
     * The progress with a range of 0 to 1
     * @type {number}
     * @memberof ModulesProgressProgressResponse
     */
    'progress'?: number;
    /**
     * 
     * @type {number}
     * @memberof ModulesProgressProgressResponse
     */
    'eta'?: number;
    /**
     * Current live preview; a data: uri
     * @type {string}
     * @memberof ModulesProgressProgressResponse
     */
    'live_preview'?: string;
    /**
     * Send this together with next request to prevent receiving same image
     * @type {number}
     * @memberof ModulesProgressProgressResponse
     */
    'id_live_preview'?: number;
    /**
     * Info text used by WebUI.
     * @type {string}
     * @memberof ModulesProgressProgressResponse
     */
    'textinfo'?: string;
}
/**
 * 
 * @export
 * @interface Options
 */
export interface Options {
    /**
     * Always save all generated images
     * @type {boolean}
     * @memberof Options
     */
    'samples_save'?: boolean;
    /**
     * File format for images
     * @type {string}
     * @memberof Options
     */
    'samples_format'?: string;
    /**
     * Images filename pattern
     * @type {any}
     * @memberof Options
     */
    'samples_filename_pattern'?: any;
    /**
     * Add number to filename when saving
     * @type {boolean}
     * @memberof Options
     */
    'save_images_add_number'?: boolean;
    /**
     * Saving the image to an existing file
     * @type {string}
     * @memberof Options
     */
    'save_images_replace_action'?: string;
    /**
     * Always save all generated image grids
     * @type {boolean}
     * @memberof Options
     */
    'grid_save'?: boolean;
    /**
     * File format for grids
     * @type {string}
     * @memberof Options
     */
    'grid_format'?: string;
    /**
     * Add extended info (seed, prompt) to filename when saving grid
     * @type {any}
     * @memberof Options
     */
    'grid_extended_filename'?: any;
    /**
     * Do not save grids consisting of one picture
     * @type {boolean}
     * @memberof Options
     */
    'grid_only_if_multiple'?: boolean;
    /**
     * Prevent empty spots in grid (when set to autodetect)
     * @type {any}
     * @memberof Options
     */
    'grid_prevent_empty_spots'?: any;
    /**
     * Archive filename pattern
     * @type {any}
     * @memberof Options
     */
    'grid_zip_filename_pattern'?: any;
    /**
     * Grid row count; use -1 for autodetect and 0 for it to be same as batch size
     * @type {number}
     * @memberof Options
     */
    'n_rows'?: number;
    /**
     * Font for image grids that have text
     * @type {any}
     * @memberof Options
     */
    'font'?: any;
    /**
     * Text color for image grids
     * @type {string}
     * @memberof Options
     */
    'grid_text_active_color'?: string;
    /**
     * Inactive text color for image grids
     * @type {string}
     * @memberof Options
     */
    'grid_text_inactive_color'?: string;
    /**
     * Background color for image grids
     * @type {string}
     * @memberof Options
     */
    'grid_background_color'?: string;
    /**
     * Save a copy of image before doing face restoration.
     * @type {any}
     * @memberof Options
     */
    'save_images_before_face_restoration'?: any;
    /**
     * Save a copy of image before applying highres fix.
     * @type {any}
     * @memberof Options
     */
    'save_images_before_highres_fix'?: any;
    /**
     * Save a copy of image before applying color correction to img2img results
     * @type {any}
     * @memberof Options
     */
    'save_images_before_color_correction'?: any;
    /**
     * For inpainting, save a copy of the greyscale mask
     * @type {any}
     * @memberof Options
     */
    'save_mask'?: any;
    /**
     * For inpainting, save a masked composite
     * @type {any}
     * @memberof Options
     */
    'save_mask_composite'?: any;
    /**
     * Quality for saved jpeg images
     * @type {number}
     * @memberof Options
     */
    'jpeg_quality'?: number;
    /**
     * Use lossless compression for webp images
     * @type {any}
     * @memberof Options
     */
    'webp_lossless'?: any;
    /**
     * Save copy of large images as JPG
     * @type {boolean}
     * @memberof Options
     */
    'export_for_4chan'?: boolean;
    /**
     * File size limit for the above option, MB
     * @type {number}
     * @memberof Options
     */
    'img_downscale_threshold'?: number;
    /**
     * Width/height limit for the above option, in pixels
     * @type {number}
     * @memberof Options
     */
    'target_side_length'?: number;
    /**
     * Maximum image size
     * @type {number}
     * @memberof Options
     */
    'img_max_size_mp'?: number;
    /**
     * Use original name for output filename during batch process in extras tab
     * @type {boolean}
     * @memberof Options
     */
    'use_original_name_batch'?: boolean;
    /**
     * Use upscaler name as filename suffix in the extras tab
     * @type {any}
     * @memberof Options
     */
    'use_upscaler_name_as_suffix'?: any;
    /**
     * When using \'Save\' button, only save a single selected image
     * @type {boolean}
     * @memberof Options
     */
    'save_selected_only'?: boolean;
    /**
     * Save init images when using img2img
     * @type {any}
     * @memberof Options
     */
    'save_init_img'?: any;
    /**
     * Directory for temporary images; leave empty for default
     * @type {any}
     * @memberof Options
     */
    'temp_dir'?: any;
    /**
     * Cleanup non-default temporary directory when starting webui
     * @type {any}
     * @memberof Options
     */
    'clean_temp_dir_at_start'?: any;
    /**
     * Save incomplete images
     * @type {any}
     * @memberof Options
     */
    'save_incomplete_images'?: any;
    /**
     * Play notification sound after image generation
     * @type {boolean}
     * @memberof Options
     */
    'notification_audio'?: boolean;
    /**
     * Notification sound volume
     * @type {number}
     * @memberof Options
     */
    'notification_volume'?: number;
    /**
     * Output directory for images; if empty, defaults to three directories below
     * @type {any}
     * @memberof Options
     */
    'outdir_samples'?: any;
    /**
     * Output directory for txt2img images
     * @type {string}
     * @memberof Options
     */
    'outdir_txt2img_samples'?: string;
    /**
     * Output directory for img2img images
     * @type {string}
     * @memberof Options
     */
    'outdir_img2img_samples'?: string;
    /**
     * Output directory for images from extras tab
     * @type {string}
     * @memberof Options
     */
    'outdir_extras_samples'?: string;
    /**
     * Output directory for grids; if empty, defaults to two directories below
     * @type {any}
     * @memberof Options
     */
    'outdir_grids'?: any;
    /**
     * Output directory for txt2img grids
     * @type {string}
     * @memberof Options
     */
    'outdir_txt2img_grids'?: string;
    /**
     * Output directory for img2img grids
     * @type {string}
     * @memberof Options
     */
    'outdir_img2img_grids'?: string;
    /**
     * Directory for saving images using the Save button
     * @type {string}
     * @memberof Options
     */
    'outdir_save'?: string;
    /**
     * Directory for saving init images when using img2img
     * @type {string}
     * @memberof Options
     */
    'outdir_init_images'?: string;
    /**
     * Save images to a subdirectory
     * @type {boolean}
     * @memberof Options
     */
    'save_to_dirs'?: boolean;
    /**
     * Save grids to a subdirectory
     * @type {boolean}
     * @memberof Options
     */
    'grid_save_to_dirs'?: boolean;
    /**
     * When using \"Save\" button, save images to a subdirectory
     * @type {any}
     * @memberof Options
     */
    'use_save_to_dirs_for_ui'?: any;
    /**
     * Directory name pattern
     * @type {string}
     * @memberof Options
     */
    'directories_filename_pattern'?: string;
    /**
     * Max prompt words for [prompt_words] pattern
     * @type {number}
     * @memberof Options
     */
    'directories_max_prompt_words'?: number;
    /**
     * Tile size for ESRGAN upscalers.
     * @type {number}
     * @memberof Options
     */
    'ESRGAN_tile'?: number;
    /**
     * Tile overlap for ESRGAN upscalers.
     * @type {number}
     * @memberof Options
     */
    'ESRGAN_tile_overlap'?: number;
    /**
     * Select which Real-ESRGAN models to show in the web UI.
     * @type {Array<any>}
     * @memberof Options
     */
    'realesrgan_enabled_models'?: Array<any>;
    /**
     * Upscaler for img2img
     * @type {any}
     * @memberof Options
     */
    'upscaler_for_img2img'?: any;
    /**
     * Restore faces
     * @type {any}
     * @memberof Options
     */
    'face_restoration'?: any;
    /**
     * Face restoration model
     * @type {string}
     * @memberof Options
     */
    'face_restoration_model'?: string;
    /**
     * CodeFormer weight
     * @type {number}
     * @memberof Options
     */
    'code_former_weight'?: number;
    /**
     * Move face restoration model from VRAM into RAM after processing
     * @type {any}
     * @memberof Options
     */
    'face_restoration_unload'?: any;
    /**
     * Automatically open webui in browser on startup
     * @type {string}
     * @memberof Options
     */
    'auto_launch_browser'?: string;
    /**
     * Print prompts to console when generating with txt2img and img2img.
     * @type {any}
     * @memberof Options
     */
    'enable_console_prompts'?: any;
    /**
     * Show warnings in console.
     * @type {any}
     * @memberof Options
     */
    'show_warnings'?: any;
    /**
     * Show gradio deprecation warnings in console.
     * @type {boolean}
     * @memberof Options
     */
    'show_gradio_deprecation_warnings'?: boolean;
    /**
     * VRAM usage polls per second during generation.
     * @type {number}
     * @memberof Options
     */
    'memmon_poll_rate'?: number;
    /**
     * Always print all generation info to standard output
     * @type {any}
     * @memberof Options
     */
    'samples_log_stdout'?: any;
    /**
     * Add a second progress bar to the console that shows progress for an entire job.
     * @type {boolean}
     * @memberof Options
     */
    'multiple_tqdm'?: boolean;
    /**
     * Print extra hypernetwork information to console.
     * @type {any}
     * @memberof Options
     */
    'print_hypernet_extra'?: any;
    /**
     * Load models/files in hidden directories
     * @type {boolean}
     * @memberof Options
     */
    'list_hidden_files'?: boolean;
    /**
     * Disable memmapping for loading .safetensors files.
     * @type {any}
     * @memberof Options
     */
    'disable_mmap_load_safetensors'?: any;
    /**
     * Prevent Stability-AI\'s ldm/sgm modules from printing noise to console.
     * @type {boolean}
     * @memberof Options
     */
    'hide_ldm_prints'?: boolean;
    /**
     * Print stack traces before exiting the program with ctrl+c.
     * @type {any}
     * @memberof Options
     */
    'dump_stacks_on_signal'?: any;
    /**
     * Allow http:// and https:// URLs for input images in API
     * @type {boolean}
     * @memberof Options
     */
    'api_enable_requests'?: boolean;
    /**
     * Forbid URLs to local resources
     * @type {boolean}
     * @memberof Options
     */
    'api_forbid_local_requests'?: boolean;
    /**
     * User agent for requests
     * @type {any}
     * @memberof Options
     */
    'api_useragent'?: any;
    /**
     * Move VAE and CLIP to RAM when training if possible. Saves VRAM.
     * @type {any}
     * @memberof Options
     */
    'unload_models_when_training'?: any;
    /**
     * Turn on pin_memory for DataLoader. Makes training slightly faster but can increase memory usage.
     * @type {any}
     * @memberof Options
     */
    'pin_memory'?: any;
    /**
     * Saves Optimizer state as separate *.optim file. Training of embedding or HN can be resumed with the matching optim file.
     * @type {any}
     * @memberof Options
     */
    'save_optimizer_state'?: any;
    /**
     * Save textual inversion and hypernet settings to a text file whenever training starts.
     * @type {boolean}
     * @memberof Options
     */
    'save_training_settings_to_txt'?: boolean;
    /**
     * Filename word regex
     * @type {any}
     * @memberof Options
     */
    'dataset_filename_word_regex'?: any;
    /**
     * Filename join string
     * @type {string}
     * @memberof Options
     */
    'dataset_filename_join_string'?: string;
    /**
     * Number of repeats for a single input image per epoch; used only for displaying epoch number
     * @type {number}
     * @memberof Options
     */
    'training_image_repeats_per_epoch'?: number;
    /**
     * Save an csv containing the loss to log directory every N steps, 0 to disable
     * @type {number}
     * @memberof Options
     */
    'training_write_csv_every'?: number;
    /**
     * Use cross attention optimizations while training
     * @type {any}
     * @memberof Options
     */
    'training_xattention_optimizations'?: any;
    /**
     * Enable tensorboard logging.
     * @type {any}
     * @memberof Options
     */
    'training_enable_tensorboard'?: any;
    /**
     * Save generated images within tensorboard.
     * @type {any}
     * @memberof Options
     */
    'training_tensorboard_save_images'?: any;
    /**
     * How often, in seconds, to flush the pending tensorboard events and summaries to disk.
     * @type {number}
     * @memberof Options
     */
    'training_tensorboard_flush_every'?: number;
    /**
     * Stable Diffusion checkpoint
     * @type {any}
     * @memberof Options
     */
    'sd_model_checkpoint'?: any;
    /**
     * Maximum number of checkpoints loaded at the same time
     * @type {number}
     * @memberof Options
     */
    'sd_checkpoints_limit'?: number;
    /**
     * Only keep one model on device
     * @type {boolean}
     * @memberof Options
     */
    'sd_checkpoints_keep_in_cpu'?: boolean;
    /**
     * Checkpoints to cache in RAM
     * @type {any}
     * @memberof Options
     */
    'sd_checkpoint_cache'?: any;
    /**
     * SD Unet
     * @type {string}
     * @memberof Options
     */
    'sd_unet'?: string;
    /**
     * Enable quantization in K samplers for sharper and cleaner results. This may change existing seeds
     * @type {any}
     * @memberof Options
     */
    'enable_quantization'?: any;
    /**
     * Enable emphasis
     * @type {boolean}
     * @memberof Options
     */
    'enable_emphasis'?: boolean;
    /**
     * Make K-diffusion samplers produce same images in a batch as when making a single image
     * @type {boolean}
     * @memberof Options
     */
    'enable_batch_seeds'?: boolean;
    /**
     * Prompt word wrap length limit
     * @type {number}
     * @memberof Options
     */
    'comma_padding_backtrack'?: number;
    /**
     * Clip skip
     * @type {number}
     * @memberof Options
     */
    'CLIP_stop_at_last_layers'?: number;
    /**
     * Upcast cross attention layer to float32
     * @type {any}
     * @memberof Options
     */
    'upcast_attn'?: any;
    /**
     * Random number generator source.
     * @type {string}
     * @memberof Options
     */
    'randn_source'?: string;
    /**
     * Tiling
     * @type {any}
     * @memberof Options
     */
    'tiling'?: any;
    /**
     * Hires fix: which pass to enable refiner for
     * @type {string}
     * @memberof Options
     */
    'hires_fix_refiner_pass'?: string;
    /**
     * crop top coordinate
     * @type {any}
     * @memberof Options
     */
    'sdxl_crop_top'?: any;
    /**
     * crop left coordinate
     * @type {any}
     * @memberof Options
     */
    'sdxl_crop_left'?: any;
    /**
     * SDXL low aesthetic score
     * @type {number}
     * @memberof Options
     */
    'sdxl_refiner_low_aesthetic_score'?: number;
    /**
     * SDXL high aesthetic score
     * @type {number}
     * @memberof Options
     */
    'sdxl_refiner_high_aesthetic_score'?: number;
    /**
     * 
     * @type {string}
     * @memberof Options
     */
    'sd_vae_explanation'?: string;
    /**
     * VAE Checkpoints to cache in RAM
     * @type {any}
     * @memberof Options
     */
    'sd_vae_checkpoint_cache'?: any;
    /**
     * SD VAE
     * @type {string}
     * @memberof Options
     */
    'sd_vae'?: string;
    /**
     * Selected VAE overrides per-model preferences
     * @type {boolean}
     * @memberof Options
     */
    'sd_vae_overrides_per_model_preferences'?: boolean;
    /**
     * Automatically revert VAE to 32-bit floats
     * @type {boolean}
     * @memberof Options
     */
    'auto_vae_precision'?: boolean;
    /**
     * VAE type for encode
     * @type {string}
     * @memberof Options
     */
    'sd_vae_encode_method'?: string;
    /**
     * VAE type for decode
     * @type {string}
     * @memberof Options
     */
    'sd_vae_decode_method'?: string;
    /**
     * Inpainting conditioning mask strength
     * @type {number}
     * @memberof Options
     */
    'inpainting_mask_weight'?: number;
    /**
     * Noise multiplier for img2img
     * @type {number}
     * @memberof Options
     */
    'initial_noise_multiplier'?: number;
    /**
     * Extra noise multiplier for img2img and hires fix
     * @type {any}
     * @memberof Options
     */
    'img2img_extra_noise'?: any;
    /**
     * Apply color correction to img2img results to match original colors.
     * @type {any}
     * @memberof Options
     */
    'img2img_color_correction'?: any;
    /**
     * With img2img, do exactly the amount of steps the slider specifies.
     * @type {any}
     * @memberof Options
     */
    'img2img_fix_steps'?: any;
    /**
     * With img2img, fill transparent parts of the input image with this color.
     * @type {string}
     * @memberof Options
     */
    'img2img_background_color'?: string;
    /**
     * Height of the image editor
     * @type {number}
     * @memberof Options
     */
    'img2img_editor_height'?: number;
    /**
     * Sketch initial brush color
     * @type {string}
     * @memberof Options
     */
    'img2img_sketch_default_brush_color'?: string;
    /**
     * Inpaint mask brush color
     * @type {string}
     * @memberof Options
     */
    'img2img_inpaint_mask_brush_color'?: string;
    /**
     * Inpaint sketch initial brush color
     * @type {string}
     * @memberof Options
     */
    'img2img_inpaint_sketch_default_brush_color'?: string;
    /**
     * For inpainting, include the greyscale mask in results for web
     * @type {any}
     * @memberof Options
     */
    'return_mask'?: any;
    /**
     * For inpainting, include masked composite in results for web
     * @type {any}
     * @memberof Options
     */
    'return_mask_composite'?: any;
    /**
     * Show the first N batch img2img results in UI
     * @type {number}
     * @memberof Options
     */
    'img2img_batch_show_results_limit'?: number;
    /**
     * Cross attention optimization
     * @type {string}
     * @memberof Options
     */
    'cross_attention_optimization'?: string;
    /**
     * Negative Guidance minimum sigma
     * @type {any}
     * @memberof Options
     */
    's_min_uncond'?: any;
    /**
     * Token merging ratio
     * @type {any}
     * @memberof Options
     */
    'token_merging_ratio'?: any;
    /**
     * Token merging ratio for img2img
     * @type {any}
     * @memberof Options
     */
    'token_merging_ratio_img2img'?: any;
    /**
     * Token merging ratio for high-res pass
     * @type {any}
     * @memberof Options
     */
    'token_merging_ratio_hr'?: any;
    /**
     * Pad prompt/negative prompt to be same length
     * @type {any}
     * @memberof Options
     */
    'pad_cond_uncond'?: any;
    /**
     * Persistent cond cache
     * @type {boolean}
     * @memberof Options
     */
    'persistent_cond_cache'?: boolean;
    /**
     * Batch cond/uncond
     * @type {boolean}
     * @memberof Options
     */
    'batch_cond_uncond'?: boolean;
    /**
     * Use old emphasis implementation. Can be useful to reproduce old seeds.
     * @type {any}
     * @memberof Options
     */
    'use_old_emphasis_implementation'?: any;
    /**
     * Use old karras scheduler sigmas (0.1 to 10).
     * @type {any}
     * @memberof Options
     */
    'use_old_karras_scheduler_sigmas'?: any;
    /**
     * Do not make DPM++ SDE deterministic across different batch sizes.
     * @type {any}
     * @memberof Options
     */
    'no_dpmpp_sde_batch_determinism'?: any;
    /**
     * For hires fix, use width/height sliders to set final resolution rather than first pass (disables Upscale by, Resize width/height to).
     * @type {any}
     * @memberof Options
     */
    'use_old_hires_fix_width_height'?: any;
    /**
     * Do not fix prompt schedule for second order samplers.
     * @type {any}
     * @memberof Options
     */
    'dont_fix_second_order_samplers_schedule'?: any;
    /**
     * For hires fix, calculate conds of second pass using extra networks of first pass.
     * @type {any}
     * @memberof Options
     */
    'hires_fix_use_firstpass_conds'?: any;
    /**
     * Use old prompt editing timelines.
     * @type {any}
     * @memberof Options
     */
    'use_old_scheduling'?: any;
    /**
     * Keep models in VRAM
     * @type {any}
     * @memberof Options
     */
    'interrogate_keep_models_in_memory'?: any;
    /**
     * Include ranks of model tags matches in results.
     * @type {any}
     * @memberof Options
     */
    'interrogate_return_ranks'?: any;
    /**
     * BLIP: num_beams
     * @type {number}
     * @memberof Options
     */
    'interrogate_clip_num_beams'?: number;
    /**
     * BLIP: minimum description length
     * @type {number}
     * @memberof Options
     */
    'interrogate_clip_min_length'?: number;
    /**
     * BLIP: maximum description length
     * @type {number}
     * @memberof Options
     */
    'interrogate_clip_max_length'?: number;
    /**
     * CLIP: maximum number of lines in text file
     * @type {number}
     * @memberof Options
     */
    'interrogate_clip_dict_limit'?: number;
    /**
     * CLIP: skip inquire categories
     * @type {any}
     * @memberof Options
     */
    'interrogate_clip_skip_categories'?: any;
    /**
     * deepbooru: score threshold
     * @type {number}
     * @memberof Options
     */
    'interrogate_deepbooru_score_threshold'?: number;
    /**
     * deepbooru: sort tags alphabetically
     * @type {boolean}
     * @memberof Options
     */
    'deepbooru_sort_alpha'?: boolean;
    /**
     * deepbooru: use spaces in tags
     * @type {boolean}
     * @memberof Options
     */
    'deepbooru_use_spaces'?: boolean;
    /**
     * deepbooru: escape (\\) brackets
     * @type {boolean}
     * @memberof Options
     */
    'deepbooru_escape'?: boolean;
    /**
     * deepbooru: filter out those tags
     * @type {any}
     * @memberof Options
     */
    'deepbooru_filter_tags'?: any;
    /**
     * Show hidden directories
     * @type {boolean}
     * @memberof Options
     */
    'extra_networks_show_hidden_directories'?: boolean;
    /**
     * Add a \'/\' to the beginning of directory buttons
     * @type {any}
     * @memberof Options
     */
    'extra_networks_dir_button_function'?: any;
    /**
     * Show cards for models in hidden directories
     * @type {string}
     * @memberof Options
     */
    'extra_networks_hidden_models'?: string;
    /**
     * Default multiplier for extra networks
     * @type {number}
     * @memberof Options
     */
    'extra_networks_default_multiplier'?: number;
    /**
     * Card width for Extra Networks
     * @type {any}
     * @memberof Options
     */
    'extra_networks_card_width'?: any;
    /**
     * Card height for Extra Networks
     * @type {any}
     * @memberof Options
     */
    'extra_networks_card_height'?: any;
    /**
     * Card text scale
     * @type {number}
     * @memberof Options
     */
    'extra_networks_card_text_scale'?: number;
    /**
     * Show description on card
     * @type {boolean}
     * @memberof Options
     */
    'extra_networks_card_show_desc'?: boolean;
    /**
     * Default order field for Extra Networks cards
     * @type {string}
     * @memberof Options
     */
    'extra_networks_card_order_field'?: string;
    /**
     * Default order for Extra Networks cards
     * @type {string}
     * @memberof Options
     */
    'extra_networks_card_order'?: string;
    /**
     * Extra networks separator
     * @type {string}
     * @memberof Options
     */
    'extra_networks_add_text_separator'?: string;
    /**
     * Extra networks tab order
     * @type {any}
     * @memberof Options
     */
    'ui_extra_networks_tab_reorder'?: any;
    /**
     * Print a list of Textual Inversion embeddings when loading model
     * @type {any}
     * @memberof Options
     */
    'textual_inversion_print_at_load'?: any;
    /**
     * Add Textual Inversion hashes to infotext
     * @type {boolean}
     * @memberof Options
     */
    'textual_inversion_add_hashes_to_infotext'?: boolean;
    /**
     * Add hypernetwork to prompt
     * @type {string}
     * @memberof Options
     */
    'sd_hypernetwork'?: string;
    /**
     * Precision for (attention:1.1) when editing the prompt with Ctrl+up/down
     * @type {number}
     * @memberof Options
     */
    'keyedit_precision_attention'?: number;
    /**
     * Precision for <extra networks:0.9> when editing the prompt with Ctrl+up/down
     * @type {number}
     * @memberof Options
     */
    'keyedit_precision_extra'?: number;
    /**
     * Word delimiters when editing the prompt with Ctrl+up/down
     * @type {string}
     * @memberof Options
     */
    'keyedit_delimiters'?: string;
    /**
     * Ctrl+up/down whitespace delimiters
     * @type {Array<any>}
     * @memberof Options
     */
    'keyedit_delimiters_whitespace'?: Array<any>;
    /**
     * Alt+left/right moves prompt elements
     * @type {boolean}
     * @memberof Options
     */
    'keyedit_move'?: boolean;
    /**
     * Disable prompt token counters
     * @type {any}
     * @memberof Options
     */
    'disable_token_counters'?: any;
    /**
     * Show grid in gallery
     * @type {boolean}
     * @memberof Options
     */
    'return_grid'?: boolean;
    /**
     * Do not show any images in gallery
     * @type {any}
     * @memberof Options
     */
    'do_not_show_images'?: any;
    /**
     * Full page image viewer: enable
     * @type {boolean}
     * @memberof Options
     */
    'js_modal_lightbox'?: boolean;
    /**
     * Full page image viewer: show images zoomed in by default
     * @type {boolean}
     * @memberof Options
     */
    'js_modal_lightbox_initially_zoomed'?: boolean;
    /**
     * Full page image viewer: navigate with gamepad
     * @type {any}
     * @memberof Options
     */
    'js_modal_lightbox_gamepad'?: any;
    /**
     * Full page image viewer: gamepad repeat period
     * @type {number}
     * @memberof Options
     */
    'js_modal_lightbox_gamepad_repeat'?: number;
    /**
     * Gallery height
     * @type {any}
     * @memberof Options
     */
    'gallery_height'?: any;
    /**
     * Compact prompt layout
     * @type {any}
     * @memberof Options
     */
    'compact_prompt_box'?: any;
    /**
     * Use dropdown for sampler selection instead of radio group
     * @type {boolean}
     * @memberof Options
     */
    'samplers_in_dropdown'?: boolean;
    /**
     * Show Width/Height and Batch sliders in same row
     * @type {boolean}
     * @memberof Options
     */
    'dimensions_and_batch_together'?: boolean;
    /**
     * Checkpoint dropdown: use filenames without paths
     * @type {any}
     * @memberof Options
     */
    'sd_checkpoint_dropdown_use_short'?: any;
    /**
     * Hires fix: show hires checkpoint and sampler selection
     * @type {any}
     * @memberof Options
     */
    'hires_fix_show_sampler'?: any;
    /**
     * Hires fix: show hires prompt and negative prompt
     * @type {any}
     * @memberof Options
     */
    'hires_fix_show_prompts'?: any;
    /**
     * Settings in txt2img hidden under Accordion
     * @type {any}
     * @memberof Options
     */
    'txt2img_settings_accordion'?: any;
    /**
     * Settings in img2img hidden under Accordion
     * @type {any}
     * @memberof Options
     */
    'img2img_settings_accordion'?: any;
    /**
     * Localization
     * @type {string}
     * @memberof Options
     */
    'localization'?: string;
    /**
     * Quicksettings list
     * @type {Array<any>}
     * @memberof Options
     */
    'quicksettings_list'?: Array<any>;
    /**
     * UI tab order
     * @type {any}
     * @memberof Options
     */
    'ui_tab_order'?: any;
    /**
     * Hidden UI tabs
     * @type {any}
     * @memberof Options
     */
    'hidden_tabs'?: any;
    /**
     * UI item order for txt2img/img2img tabs
     * @type {any}
     * @memberof Options
     */
    'ui_reorder_list'?: any;
    /**
     * Gradio theme
     * @type {string}
     * @memberof Options
     */
    'gradio_theme'?: string;
    /**
     * Cache gradio themes locally
     * @type {boolean}
     * @memberof Options
     */
    'gradio_themes_cache'?: boolean;
    /**
     * Show generation progress in window title.
     * @type {boolean}
     * @memberof Options
     */
    'show_progress_in_title'?: boolean;
    /**
     * Send seed when sending prompt or image to other interface
     * @type {boolean}
     * @memberof Options
     */
    'send_seed'?: boolean;
    /**
     * Send size when sending prompt or image to another interface
     * @type {boolean}
     * @memberof Options
     */
    'send_size'?: boolean;
    /**
     * 
     * @type {string}
     * @memberof Options
     */
    'infotext_explanation'?: string;
    /**
     * Write infotext to metadata of the generated image
     * @type {boolean}
     * @memberof Options
     */
    'enable_pnginfo'?: boolean;
    /**
     * Create a text file with infotext next to every generated image
     * @type {any}
     * @memberof Options
     */
    'save_txt'?: any;
    /**
     * Add model name to infotext
     * @type {boolean}
     * @memberof Options
     */
    'add_model_name_to_info'?: boolean;
    /**
     * Add model hash to infotext
     * @type {boolean}
     * @memberof Options
     */
    'add_model_hash_to_info'?: boolean;
    /**
     * Add VAE name to infotext
     * @type {boolean}
     * @memberof Options
     */
    'add_vae_name_to_info'?: boolean;
    /**
     * Add VAE hash to infotext
     * @type {boolean}
     * @memberof Options
     */
    'add_vae_hash_to_info'?: boolean;
    /**
     * Add user name to infotext when authenticated
     * @type {any}
     * @memberof Options
     */
    'add_user_name_to_info'?: any;
    /**
     * Add program version to infotext
     * @type {boolean}
     * @memberof Options
     */
    'add_version_to_infotext'?: boolean;
    /**
     * Disregard checkpoint information from pasted infotext
     * @type {boolean}
     * @memberof Options
     */
    'disable_weights_auto_swap'?: boolean;
    /**
     * Disregard fields from pasted infotext
     * @type {any}
     * @memberof Options
     */
    'infotext_skip_pasting'?: any;
    /**
     * Infer styles from prompts of pasted infotext
     * @type {string}
     * @memberof Options
     */
    'infotext_styles'?: string;
    /**
     * Show progressbar
     * @type {boolean}
     * @memberof Options
     */
    'show_progressbar'?: boolean;
    /**
     * Show live previews of the created image
     * @type {boolean}
     * @memberof Options
     */
    'live_previews_enable'?: boolean;
    /**
     * Live preview file format
     * @type {string}
     * @memberof Options
     */
    'live_previews_image_format'?: string;
    /**
     * Show previews of all images generated in a batch as a grid
     * @type {boolean}
     * @memberof Options
     */
    'show_progress_grid'?: boolean;
    /**
     * Live preview display period
     * @type {number}
     * @memberof Options
     */
    'show_progress_every_n_steps'?: number;
    /**
     * Live preview method
     * @type {string}
     * @memberof Options
     */
    'show_progress_type'?: string;
    /**
     * Allow Full live preview method with lowvram/medvram
     * @type {any}
     * @memberof Options
     */
    'live_preview_allow_lowvram_full'?: any;
    /**
     * Live preview subject
     * @type {string}
     * @memberof Options
     */
    'live_preview_content'?: string;
    /**
     * Progressbar and preview update period
     * @type {number}
     * @memberof Options
     */
    'live_preview_refresh_period'?: number;
    /**
     * Return image with chosen live preview method on interrupt
     * @type {any}
     * @memberof Options
     */
    'live_preview_fast_interrupt'?: any;
    /**
     * Show Live preview in full page image viewer
     * @type {any}
     * @memberof Options
     */
    'js_live_preview_in_modal_lightbox'?: any;
    /**
     * Hide samplers in user interface
     * @type {any}
     * @memberof Options
     */
    'hide_samplers'?: any;
    /**
     * Eta for DDIM
     * @type {any}
     * @memberof Options
     */
    'eta_ddim'?: any;
    /**
     * Eta for k-diffusion samplers
     * @type {number}
     * @memberof Options
     */
    'eta_ancestral'?: number;
    /**
     * img2img DDIM discretize
     * @type {string}
     * @memberof Options
     */
    'ddim_discretize'?: string;
    /**
     * sigma churn
     * @type {any}
     * @memberof Options
     */
    's_churn'?: any;
    /**
     * sigma tmin
     * @type {any}
     * @memberof Options
     */
    's_tmin'?: any;
    /**
     * sigma tmax
     * @type {any}
     * @memberof Options
     */
    's_tmax'?: any;
    /**
     * sigma noise
     * @type {number}
     * @memberof Options
     */
    's_noise'?: number;
    /**
     * Scheduler type
     * @type {string}
     * @memberof Options
     */
    'k_sched_type'?: string;
    /**
     * sigma min
     * @type {any}
     * @memberof Options
     */
    'sigma_min'?: any;
    /**
     * sigma max
     * @type {any}
     * @memberof Options
     */
    'sigma_max'?: any;
    /**
     * rho
     * @type {any}
     * @memberof Options
     */
    'rho'?: any;
    /**
     * Eta noise seed delta
     * @type {any}
     * @memberof Options
     */
    'eta_noise_seed_delta'?: any;
    /**
     * Always discard next-to-last sigma
     * @type {any}
     * @memberof Options
     */
    'always_discard_next_to_last_sigma'?: any;
    /**
     * SGM noise multiplier
     * @type {any}
     * @memberof Options
     */
    'sgm_noise_multiplier'?: any;
    /**
     * UniPC variant
     * @type {string}
     * @memberof Options
     */
    'uni_pc_variant'?: string;
    /**
     * UniPC skip type
     * @type {string}
     * @memberof Options
     */
    'uni_pc_skip_type'?: string;
    /**
     * UniPC order
     * @type {number}
     * @memberof Options
     */
    'uni_pc_order'?: number;
    /**
     * UniPC lower order final
     * @type {boolean}
     * @memberof Options
     */
    'uni_pc_lower_order_final'?: boolean;
    /**
     * Enable postprocessing operations in txt2img and img2img tabs
     * @type {any}
     * @memberof Options
     */
    'postprocessing_enable_in_main_ui'?: any;
    /**
     * Postprocessing operation order
     * @type {any}
     * @memberof Options
     */
    'postprocessing_operation_order'?: any;
    /**
     * Maximum number of images in upscaling cache
     * @type {number}
     * @memberof Options
     */
    'upscaling_max_images_in_cache'?: number;
    /**
     * Action for existing captions
     * @type {string}
     * @memberof Options
     */
    'postprocessing_existing_caption_action'?: string;
    /**
     * Disable these extensions
     * @type {any}
     * @memberof Options
     */
    'disabled_extensions'?: any;
    /**
     * Disable all extensions (preserves the list of disabled extensions)
     * @type {string}
     * @memberof Options
     */
    'disable_all_extensions'?: string;
    /**
     * Config state file to restore from, under \'config-states/\' folder
     * @type {any}
     * @memberof Options
     */
    'restore_config_state_file'?: any;
    /**
     * SHA256 hash of the current checkpoint
     * @type {any}
     * @memberof Options
     */
    'sd_checkpoint_hash'?: any;
    /**
     * Add network to prompt
     * @type {string}
     * @memberof Options
     */
    'sd_lora'?: string;
    /**
     * When adding to prompt, refer to Lora by
     * @type {string}
     * @memberof Options
     */
    'lora_preferred_name'?: string;
    /**
     * Add Lora hashes to infotext
     * @type {boolean}
     * @memberof Options
     */
    'lora_add_hashes_to_infotext'?: boolean;
    /**
     * Always show all networks on the Lora page
     * @type {any}
     * @memberof Options
     */
    'lora_show_all'?: any;
    /**
     * Hide networks of unknown versions for model versions
     * @type {any}
     * @memberof Options
     */
    'lora_hide_unknown_for_versions'?: any;
    /**
     * Number of Lora networks to keep cached in memory
     * @type {any}
     * @memberof Options
     */
    'lora_in_memory_limit'?: any;
    /**
     * Lora/Networks: use old method that takes longer when you have multiple Loras active and produces same results as kohya-ss/sd-webui-additional-networks extension
     * @type {any}
     * @memberof Options
     */
    'lora_functional'?: any;
    /**
     * Zoom canvas
     * @type {string}
     * @memberof Options
     */
    'canvas_hotkey_zoom'?: string;
    /**
     * Adjust brush size
     * @type {string}
     * @memberof Options
     */
    'canvas_hotkey_adjust'?: string;
    /**
     * Moving the canvas
     * @type {string}
     * @memberof Options
     */
    'canvas_hotkey_move'?: string;
    /**
     * Fullscreen Mode, maximizes the picture so that it fits into the screen and stretches it to its full width 
     * @type {string}
     * @memberof Options
     */
    'canvas_hotkey_fullscreen'?: string;
    /**
     * Reset zoom and canvas positon
     * @type {string}
     * @memberof Options
     */
    'canvas_hotkey_reset'?: string;
    /**
     * Toggle overlap
     * @type {string}
     * @memberof Options
     */
    'canvas_hotkey_overlap'?: string;
    /**
     * Enable tooltip on the canvas
     * @type {boolean}
     * @memberof Options
     */
    'canvas_show_tooltip'?: boolean;
    /**
     * Automatically expands an image that does not fit completely in the canvas area, similar to manually pressing the S and R buttons
     * @type {boolean}
     * @memberof Options
     */
    'canvas_auto_expand'?: boolean;
    /**
     * Take the focus off the prompt when working with a canvas
     * @type {any}
     * @memberof Options
     */
    'canvas_blur_prompt'?: any;
    /**
     * Disable function that you don\'t use
     * @type {Array<any>}
     * @memberof Options
     */
    'canvas_disabled_functions'?: Array<any>;
    /**
     * 
     * @type {string}
     * @memberof Options
     */
    'settings_in_ui'?: string;
    /**
     * Settings for txt2img
     * @type {any}
     * @memberof Options
     */
    'extra_options_txt2img'?: any;
    /**
     * Settings for img2img
     * @type {any}
     * @memberof Options
     */
    'extra_options_img2img'?: any;
    /**
     * Number of columns for added settings
     * @type {number}
     * @memberof Options
     */
    'extra_options_cols'?: number;
    /**
     * Place added settings into an accordion
     * @type {any}
     * @memberof Options
     */
    'extra_options_accordion'?: any;
}
/**
 * 
 * @export
 * @interface PNGInfoRequest
 */
export interface PNGInfoRequest {
    /**
     * The base64 encoded PNG image
     * @type {string}
     * @memberof PNGInfoRequest
     */
    'image': string;
}
/**
 * 
 * @export
 * @interface PNGInfoResponse
 */
export interface PNGInfoResponse {
    /**
     * A string with the parameters used to generate the image
     * @type {string}
     * @memberof PNGInfoResponse
     */
    'info': string;
    /**
     * A dictionary containing all the other fields the image had
     * @type {object}
     * @memberof PNGInfoResponse
     */
    'items': object;
    /**
     * A dictionary with parsed generation info fields
     * @type {object}
     * @memberof PNGInfoResponse
     */
    'parameters': object;
}
/**
 * 
 * @export
 * @interface PredictBody
 */
export interface PredictBody {
    /**
     * 
     * @type {string}
     * @memberof PredictBody
     */
    'session_hash'?: string;
    /**
     * 
     * @type {string}
     * @memberof PredictBody
     */
    'event_id'?: string;
    /**
     * 
     * @type {Array<any>}
     * @memberof PredictBody
     */
    'data': Array<any>;
    /**
     * 
     * @type {any}
     * @memberof PredictBody
     */
    'event_data'?: any;
    /**
     * 
     * @type {number}
     * @memberof PredictBody
     */
    'fn_index'?: number;
    /**
     * 
     * @type {boolean}
     * @memberof PredictBody
     */
    'batched'?: boolean;
    /**
     * 
     * @type {Request}
     * @memberof PredictBody
     */
    'request'?: Request;
}
/**
 * 
 * @export
 * @interface ProgressRequest
 */
export interface ProgressRequest {
    /**
     * id of the task to get progress for
     * @type {string}
     * @memberof ProgressRequest
     */
    'id_task'?: string;
    /**
     * id of last received last preview image
     * @type {number}
     * @memberof ProgressRequest
     */
    'id_live_preview'?: number;
    /**
     * boolean flag indicating whether to include the live preview image
     * @type {boolean}
     * @memberof ProgressRequest
     */
    'live_preview'?: boolean;
}
/**
 * 
 * @export
 * @interface PromptStyleItem
 */
export interface PromptStyleItem {
    /**
     * 
     * @type {string}
     * @memberof PromptStyleItem
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof PromptStyleItem
     */
    'prompt'?: string;
    /**
     * 
     * @type {string}
     * @memberof PromptStyleItem
     */
    'negative_prompt'?: string;
}
/**
 * 
 * @export
 * @interface QuicksettingsHint
 */
export interface QuicksettingsHint {
    /**
     * 
     * @type {string}
     * @memberof QuicksettingsHint
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof QuicksettingsHint
     */
    'label': string;
}
/**
 * 
 * @export
 * @interface RealesrganItem
 */
export interface RealesrganItem {
    /**
     * 
     * @type {string}
     * @memberof RealesrganItem
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof RealesrganItem
     */
    'path'?: string;
    /**
     * 
     * @type {number}
     * @memberof RealesrganItem
     */
    'scale'?: number;
}
/**
 * 
 * @export
 * @interface Request
 */
export interface Request {
}
/**
 * 
 * @export
 * @interface ResetBody
 */
export interface ResetBody {
    /**
     * 
     * @type {string}
     * @memberof ResetBody
     */
    'session_hash': string;
    /**
     * 
     * @type {number}
     * @memberof ResetBody
     */
    'fn_index': number;
}
/**
 * 
 * @export
 * @interface SDModelItem
 */
export interface SDModelItem {
    /**
     * 
     * @type {string}
     * @memberof SDModelItem
     */
    'title': string;
    /**
     * 
     * @type {string}
     * @memberof SDModelItem
     */
    'model_name': string;
    /**
     * 
     * @type {string}
     * @memberof SDModelItem
     */
    'hash'?: string;
    /**
     * 
     * @type {string}
     * @memberof SDModelItem
     */
    'sha256'?: string;
    /**
     * 
     * @type {string}
     * @memberof SDModelItem
     */
    'filename': string;
    /**
     * 
     * @type {string}
     * @memberof SDModelItem
     */
    'config'?: string;
}
/**
 * 
 * @export
 * @interface SDVaeItem
 */
export interface SDVaeItem {
    /**
     * 
     * @type {string}
     * @memberof SDVaeItem
     */
    'model_name': string;
    /**
     * 
     * @type {string}
     * @memberof SDVaeItem
     */
    'filename': string;
}
/**
 * 
 * @export
 * @interface SamplerItem
 */
export interface SamplerItem {
    /**
     * 
     * @type {string}
     * @memberof SamplerItem
     */
    'name': string;
    /**
     * 
     * @type {Array<string>}
     * @memberof SamplerItem
     */
    'aliases': Array<string>;
    /**
     * 
     * @type {{ [key: string]: string; }}
     * @memberof SamplerItem
     */
    'options': { [key: string]: string; };
}
/**
 * 
 * @export
 * @interface ScriptArg
 */
export interface ScriptArg {
    /**
     * Name of the argument in UI
     * @type {string}
     * @memberof ScriptArg
     */
    'label'?: string;
    /**
     * Default value of the argument
     * @type {any}
     * @memberof ScriptArg
     */
    'value'?: any;
    /**
     * Minimum allowed value for the argumentin UI
     * @type {any}
     * @memberof ScriptArg
     */
    'minimum'?: any;
    /**
     * Maximum allowed value for the argumentin UI
     * @type {any}
     * @memberof ScriptArg
     */
    'maximum'?: any;
    /**
     * Step for changing value of the argumentin UI
     * @type {any}
     * @memberof ScriptArg
     */
    'step'?: any;
    /**
     * Possible values for the argument
     * @type {Array<string>}
     * @memberof ScriptArg
     */
    'choices'?: Array<string>;
}
/**
 * 
 * @export
 * @interface ScriptInfo
 */
export interface ScriptInfo {
    /**
     * Script name
     * @type {string}
     * @memberof ScriptInfo
     */
    'name'?: string;
    /**
     * Flag specifying whether this script is an alwayson script
     * @type {boolean}
     * @memberof ScriptInfo
     */
    'is_alwayson'?: boolean;
    /**
     * Flag specifying whether this script is an img2img script
     * @type {boolean}
     * @memberof ScriptInfo
     */
    'is_img2img'?: boolean;
    /**
     * List of script\'s arguments
     * @type {Array<ScriptArg>}
     * @memberof ScriptInfo
     */
    'args': Array<ScriptArg>;
}
/**
 * 
 * @export
 * @interface ScriptsList
 */
export interface ScriptsList {
    /**
     * Titles of scripts (txt2img)
     * @type {Array<any>}
     * @memberof ScriptsList
     */
    'txt2img'?: Array<any>;
    /**
     * Titles of scripts (img2img)
     * @type {Array<any>}
     * @memberof ScriptsList
     */
    'img2img'?: Array<any>;
}
/**
 * 
 * @export
 * @interface StableDiffusionProcessingImg2Img
 */
export interface StableDiffusionProcessingImg2Img {
    /**
     * 
     * @type {string}
     * @memberof StableDiffusionProcessingImg2Img
     */
    'prompt'?: string;
    /**
     * 
     * @type {string}
     * @memberof StableDiffusionProcessingImg2Img
     */
    'negative_prompt'?: string;
    /**
     * 
     * @type {Array<string>}
     * @memberof StableDiffusionProcessingImg2Img
     */
    'styles'?: Array<string>;
    /**
     * 
     * @type {number}
     * @memberof StableDiffusionProcessingImg2Img
     */
    'seed'?: number;
    /**
     * 
     * @type {number}
     * @memberof StableDiffusionProcessingImg2Img
     */
    'subseed'?: number;
    /**
     * 
     * @type {number}
     * @memberof StableDiffusionProcessingImg2Img
     */
    'subseed_strength'?: number;
    /**
     * 
     * @type {number}
     * @memberof StableDiffusionProcessingImg2Img
     */
    'seed_resize_from_h'?: number;
    /**
     * 
     * @type {number}
     * @memberof StableDiffusionProcessingImg2Img
     */
    'seed_resize_from_w'?: number;
    /**
     * 
     * @type {string}
     * @memberof StableDiffusionProcessingImg2Img
     */
    'sampler_name'?: string;
    /**
     * 
     * @type {number}
     * @memberof StableDiffusionProcessingImg2Img
     */
    'batch_size'?: number;
    /**
     * 
     * @type {number}
     * @memberof StableDiffusionProcessingImg2Img
     */
    'n_iter'?: number;
    /**
     * 
     * @type {number}
     * @memberof StableDiffusionProcessingImg2Img
     */
    'steps'?: number;
    /**
     * 
     * @type {number}
     * @memberof StableDiffusionProcessingImg2Img
     */
    'cfg_scale'?: number;
    /**
     * 
     * @type {number}
     * @memberof StableDiffusionProcessingImg2Img
     */
    'width'?: number;
    /**
     * 
     * @type {number}
     * @memberof StableDiffusionProcessingImg2Img
     */
    'height'?: number;
    /**
     * 
     * @type {boolean}
     * @memberof StableDiffusionProcessingImg2Img
     */
    'restore_faces'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof StableDiffusionProcessingImg2Img
     */
    'tiling'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof StableDiffusionProcessingImg2Img
     */
    'do_not_save_samples'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof StableDiffusionProcessingImg2Img
     */
    'do_not_save_grid'?: boolean;
    /**
     * 
     * @type {number}
     * @memberof StableDiffusionProcessingImg2Img
     */
    'eta'?: number;
    /**
     * 
     * @type {number}
     * @memberof StableDiffusionProcessingImg2Img
     */
    'denoising_strength'?: number;
    /**
     * 
     * @type {number}
     * @memberof StableDiffusionProcessingImg2Img
     */
    's_min_uncond'?: number;
    /**
     * 
     * @type {number}
     * @memberof StableDiffusionProcessingImg2Img
     */
    's_churn'?: number;
    /**
     * 
     * @type {number}
     * @memberof StableDiffusionProcessingImg2Img
     */
    's_tmax'?: number;
    /**
     * 
     * @type {number}
     * @memberof StableDiffusionProcessingImg2Img
     */
    's_tmin'?: number;
    /**
     * 
     * @type {number}
     * @memberof StableDiffusionProcessingImg2Img
     */
    's_noise'?: number;
    /**
     * 
     * @type {object}
     * @memberof StableDiffusionProcessingImg2Img
     */
    'override_settings'?: object;
    /**
     * 
     * @type {boolean}
     * @memberof StableDiffusionProcessingImg2Img
     */
    'override_settings_restore_afterwards'?: boolean;
    /**
     * 
     * @type {string}
     * @memberof StableDiffusionProcessingImg2Img
     */
    'refiner_checkpoint'?: string;
    /**
     * 
     * @type {number}
     * @memberof StableDiffusionProcessingImg2Img
     */
    'refiner_switch_at'?: number;
    /**
     * 
     * @type {boolean}
     * @memberof StableDiffusionProcessingImg2Img
     */
    'disable_extra_networks'?: boolean;
    /**
     * 
     * @type {object}
     * @memberof StableDiffusionProcessingImg2Img
     */
    'comments'?: object;
    /**
     * 
     * @type {Array<any>}
     * @memberof StableDiffusionProcessingImg2Img
     */
    'init_images'?: Array<any>;
    /**
     * 
     * @type {number}
     * @memberof StableDiffusionProcessingImg2Img
     */
    'resize_mode'?: number;
    /**
     * 
     * @type {number}
     * @memberof StableDiffusionProcessingImg2Img
     */
    'image_cfg_scale'?: number;
    /**
     * 
     * @type {string}
     * @memberof StableDiffusionProcessingImg2Img
     */
    'mask'?: string;
    /**
     * 
     * @type {number}
     * @memberof StableDiffusionProcessingImg2Img
     */
    'mask_blur_x'?: number;
    /**
     * 
     * @type {number}
     * @memberof StableDiffusionProcessingImg2Img
     */
    'mask_blur_y'?: number;
    /**
     * 
     * @type {number}
     * @memberof StableDiffusionProcessingImg2Img
     */
    'mask_blur'?: number;
    /**
     * 
     * @type {number}
     * @memberof StableDiffusionProcessingImg2Img
     */
    'inpainting_fill'?: number;
    /**
     * 
     * @type {boolean}
     * @memberof StableDiffusionProcessingImg2Img
     */
    'inpaint_full_res'?: boolean;
    /**
     * 
     * @type {number}
     * @memberof StableDiffusionProcessingImg2Img
     */
    'inpaint_full_res_padding'?: number;
    /**
     * 
     * @type {number}
     * @memberof StableDiffusionProcessingImg2Img
     */
    'inpainting_mask_invert'?: number;
    /**
     * 
     * @type {number}
     * @memberof StableDiffusionProcessingImg2Img
     */
    'initial_noise_multiplier'?: number;
    /**
     * 
     * @type {string}
     * @memberof StableDiffusionProcessingImg2Img
     */
    'latent_mask'?: string;
    /**
     * 
     * @type {string}
     * @memberof StableDiffusionProcessingImg2Img
     */
    'sampler_index'?: string;
    /**
     * 
     * @type {boolean}
     * @memberof StableDiffusionProcessingImg2Img
     */
    'include_init_images'?: boolean;
    /**
     * 
     * @type {string}
     * @memberof StableDiffusionProcessingImg2Img
     */
    'script_name'?: string;
    /**
     * 
     * @type {Array<any>}
     * @memberof StableDiffusionProcessingImg2Img
     */
    'script_args'?: Array<any>;
    /**
     * 
     * @type {boolean}
     * @memberof StableDiffusionProcessingImg2Img
     */
    'send_images'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof StableDiffusionProcessingImg2Img
     */
    'save_images'?: boolean;
    /**
     * 
     * @type {object}
     * @memberof StableDiffusionProcessingImg2Img
     */
    'alwayson_scripts'?: object;
}
/**
 * 
 * @export
 * @interface StableDiffusionProcessingTxt2Img
 */
export interface StableDiffusionProcessingTxt2Img {
    /**
     * 
     * @type {string}
     * @memberof StableDiffusionProcessingTxt2Img
     */
    'prompt'?: string;
    /**
     * 
     * @type {string}
     * @memberof StableDiffusionProcessingTxt2Img
     */
    'negative_prompt'?: string;
    /**
     * 
     * @type {Array<string>}
     * @memberof StableDiffusionProcessingTxt2Img
     */
    'styles'?: Array<string>;
    /**
     * 
     * @type {number}
     * @memberof StableDiffusionProcessingTxt2Img
     */
    'seed'?: number;
    /**
     * 
     * @type {number}
     * @memberof StableDiffusionProcessingTxt2Img
     */
    'subseed'?: number;
    /**
     * 
     * @type {number}
     * @memberof StableDiffusionProcessingTxt2Img
     */
    'subseed_strength'?: number;
    /**
     * 
     * @type {number}
     * @memberof StableDiffusionProcessingTxt2Img
     */
    'seed_resize_from_h'?: number;
    /**
     * 
     * @type {number}
     * @memberof StableDiffusionProcessingTxt2Img
     */
    'seed_resize_from_w'?: number;
    /**
     * 
     * @type {string}
     * @memberof StableDiffusionProcessingTxt2Img
     */
    'sampler_name'?: string;
    /**
     * 
     * @type {number}
     * @memberof StableDiffusionProcessingTxt2Img
     */
    'batch_size'?: number;
    /**
     * 
     * @type {number}
     * @memberof StableDiffusionProcessingTxt2Img
     */
    'n_iter'?: number;
    /**
     * 
     * @type {number}
     * @memberof StableDiffusionProcessingTxt2Img
     */
    'steps'?: number;
    /**
     * 
     * @type {number}
     * @memberof StableDiffusionProcessingTxt2Img
     */
    'cfg_scale'?: number;
    /**
     * 
     * @type {number}
     * @memberof StableDiffusionProcessingTxt2Img
     */
    'width'?: number;
    /**
     * 
     * @type {number}
     * @memberof StableDiffusionProcessingTxt2Img
     */
    'height'?: number;
    /**
     * 
     * @type {boolean}
     * @memberof StableDiffusionProcessingTxt2Img
     */
    'restore_faces'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof StableDiffusionProcessingTxt2Img
     */
    'tiling'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof StableDiffusionProcessingTxt2Img
     */
    'do_not_save_samples'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof StableDiffusionProcessingTxt2Img
     */
    'do_not_save_grid'?: boolean;
    /**
     * 
     * @type {number}
     * @memberof StableDiffusionProcessingTxt2Img
     */
    'eta'?: number;
    /**
     * 
     * @type {number}
     * @memberof StableDiffusionProcessingTxt2Img
     */
    'denoising_strength'?: number;
    /**
     * 
     * @type {number}
     * @memberof StableDiffusionProcessingTxt2Img
     */
    's_min_uncond'?: number;
    /**
     * 
     * @type {number}
     * @memberof StableDiffusionProcessingTxt2Img
     */
    's_churn'?: number;
    /**
     * 
     * @type {number}
     * @memberof StableDiffusionProcessingTxt2Img
     */
    's_tmax'?: number;
    /**
     * 
     * @type {number}
     * @memberof StableDiffusionProcessingTxt2Img
     */
    's_tmin'?: number;
    /**
     * 
     * @type {number}
     * @memberof StableDiffusionProcessingTxt2Img
     */
    's_noise'?: number;
    /**
     * 
     * @type {object}
     * @memberof StableDiffusionProcessingTxt2Img
     */
    'override_settings'?: object;
    /**
     * 
     * @type {boolean}
     * @memberof StableDiffusionProcessingTxt2Img
     */
    'override_settings_restore_afterwards'?: boolean;
    /**
     * 
     * @type {string}
     * @memberof StableDiffusionProcessingTxt2Img
     */
    'refiner_checkpoint'?: string;
    /**
     * 
     * @type {number}
     * @memberof StableDiffusionProcessingTxt2Img
     */
    'refiner_switch_at'?: number;
    /**
     * 
     * @type {boolean}
     * @memberof StableDiffusionProcessingTxt2Img
     */
    'disable_extra_networks'?: boolean;
    /**
     * 
     * @type {object}
     * @memberof StableDiffusionProcessingTxt2Img
     */
    'comments'?: object;
    /**
     * 
     * @type {boolean}
     * @memberof StableDiffusionProcessingTxt2Img
     */
    'enable_hr'?: boolean;
    /**
     * 
     * @type {number}
     * @memberof StableDiffusionProcessingTxt2Img
     */
    'firstphase_width'?: number;
    /**
     * 
     * @type {number}
     * @memberof StableDiffusionProcessingTxt2Img
     */
    'firstphase_height'?: number;
    /**
     * 
     * @type {number}
     * @memberof StableDiffusionProcessingTxt2Img
     */
    'hr_scale'?: number;
    /**
     * 
     * @type {string}
     * @memberof StableDiffusionProcessingTxt2Img
     */
    'hr_upscaler'?: string;
    /**
     * 
     * @type {number}
     * @memberof StableDiffusionProcessingTxt2Img
     */
    'hr_second_pass_steps'?: number;
    /**
     * 
     * @type {number}
     * @memberof StableDiffusionProcessingTxt2Img
     */
    'hr_resize_x'?: number;
    /**
     * 
     * @type {number}
     * @memberof StableDiffusionProcessingTxt2Img
     */
    'hr_resize_y'?: number;
    /**
     * 
     * @type {string}
     * @memberof StableDiffusionProcessingTxt2Img
     */
    'hr_checkpoint_name'?: string;
    /**
     * 
     * @type {string}
     * @memberof StableDiffusionProcessingTxt2Img
     */
    'hr_sampler_name'?: string;
    /**
     * 
     * @type {string}
     * @memberof StableDiffusionProcessingTxt2Img
     */
    'hr_prompt'?: string;
    /**
     * 
     * @type {string}
     * @memberof StableDiffusionProcessingTxt2Img
     */
    'hr_negative_prompt'?: string;
    /**
     * 
     * @type {string}
     * @memberof StableDiffusionProcessingTxt2Img
     */
    'sampler_index'?: string;
    /**
     * 
     * @type {string}
     * @memberof StableDiffusionProcessingTxt2Img
     */
    'script_name'?: string;
    /**
     * 
     * @type {Array<any>}
     * @memberof StableDiffusionProcessingTxt2Img
     */
    'script_args'?: Array<any>;
    /**
     * 
     * @type {boolean}
     * @memberof StableDiffusionProcessingTxt2Img
     */
    'send_images'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof StableDiffusionProcessingTxt2Img
     */
    'save_images'?: boolean;
    /**
     * 
     * @type {object}
     * @memberof StableDiffusionProcessingTxt2Img
     */
    'alwayson_scripts'?: object;
}
/**
 * 
 * @export
 * @interface TextToImageResponse
 */
export interface TextToImageResponse {
    /**
     * The generated image in base64 format.
     * @type {Array<string>}
     * @memberof TextToImageResponse
     */
    'images'?: Array<string>;
    /**
     * 
     * @type {object}
     * @memberof TextToImageResponse
     */
    'parameters': object;
    /**
     * 
     * @type {string}
     * @memberof TextToImageResponse
     */
    'info': string;
}
/**
 * 
 * @export
 * @interface TrainResponse
 */
export interface TrainResponse {
    /**
     * Response string from train embedding or hypernetwork task.
     * @type {string}
     * @memberof TrainResponse
     */
    'info': string;
}
/**
 * 
 * @export
 * @interface UpscalerItem
 */
export interface UpscalerItem {
    /**
     * 
     * @type {string}
     * @memberof UpscalerItem
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof UpscalerItem
     */
    'model_name'?: string;
    /**
     * 
     * @type {string}
     * @memberof UpscalerItem
     */
    'model_path'?: string;
    /**
     * 
     * @type {string}
     * @memberof UpscalerItem
     */
    'model_url'?: string;
    /**
     * 
     * @type {number}
     * @memberof UpscalerItem
     */
    'scale'?: number;
}
/**
 * 
 * @export
 * @interface ValidationError
 */
export interface ValidationError {
    /**
     * 
     * @type {Array<LocationInner>}
     * @memberof ValidationError
     */
    'loc': Array<LocationInner>;
    /**
     * 
     * @type {string}
     * @memberof ValidationError
     */
    'msg': string;
    /**
     * 
     * @type {string}
     * @memberof ValidationError
     */
    'type': string;
}

/**
 * DefaultApi - axios parameter creator
 * @export
 */
export const DefaultApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Api Info
         * @param {boolean} [serialize] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiInfoInfoGet: async (serialize?: boolean, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/info`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (serialize !== undefined) {
                localVarQueryParameter['serialize'] = serialize;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Api Info
         * @param {boolean} [serialize] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiInfoInfoGet_1: async (serialize?: boolean, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/info/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (serialize !== undefined) {
                localVarQueryParameter['serialize'] = serialize;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary App Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        appIdAppIdGet: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/app_id/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary App Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        appIdAppIdGet_2: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/app_id`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Build Resource
         * @param {string} path 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        buildResourceAssetsPathGet: async (path: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'path' is not null or undefined
            assertParamExists('buildResourceAssetsPathGet', 'path', path)
            const localVarPath = `/assets/{path}`
                .replace(`{${"path"}}`, encodeURIComponent(String(path)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Create Embedding
         * @param {object} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createEmbeddingSdapiV1CreateEmbeddingPost: async (body: object, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'body' is not null or undefined
            assertParamExists('createEmbeddingSdapiV1CreateEmbeddingPost', 'body', body)
            const localVarPath = `/sdapi/v1/create/embedding`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Create Hypernetwork
         * @param {object} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createHypernetworkSdapiV1CreateHypernetworkPost: async (body: object, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'body' is not null or undefined
            assertParamExists('createHypernetworkSdapiV1CreateHypernetworkPost', 'body', body)
            const localVarPath = `/sdapi/v1/create/hypernetwork`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Download Sysinfo
         * @param {any} [attachment] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        downloadSysinfoInternalSysinfoGet: async (attachment?: any, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/internal/sysinfo`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (attachment !== undefined) {
                for (const [key, value] of Object.entries(attachment)) {
                    localVarQueryParameter[key] = value;
                }
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Extras Batch Images Api
         * @param {ExtrasBatchImagesRequest} extrasBatchImagesRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        extrasBatchImagesApiSdapiV1ExtraBatchImagesPost: async (extrasBatchImagesRequest: ExtrasBatchImagesRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'extrasBatchImagesRequest' is not null or undefined
            assertParamExists('extrasBatchImagesApiSdapiV1ExtraBatchImagesPost', 'extrasBatchImagesRequest', extrasBatchImagesRequest)
            const localVarPath = `/sdapi/v1/extra-batch-images`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(extrasBatchImagesRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Extras Single Image Api
         * @param {ExtrasSingleImageRequest} extrasSingleImageRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        extrasSingleImageApiSdapiV1ExtraSingleImagePost: async (extrasSingleImageRequest: ExtrasSingleImageRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'extrasSingleImageRequest' is not null or undefined
            assertParamExists('extrasSingleImageApiSdapiV1ExtraSingleImagePost', 'extrasSingleImageRequest', extrasSingleImageRequest)
            const localVarPath = `/sdapi/v1/extra-single-image`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(extrasSingleImageRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Favicon
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        faviconFaviconIcoGet: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/favicon.ico`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Fetch File
         * @param {string} [filename] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        fetchFileSdExtraNetworksThumbGet: async (filename?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/sd_extra_networks/thumb`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (filename !== undefined) {
                localVarQueryParameter['filename'] = filename;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary File Deprecated
         * @param {string} path 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        fileDeprecatedFilePathGet: async (path: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'path' is not null or undefined
            assertParamExists('fileDeprecatedFilePathGet', 'path', path)
            const localVarPath = `/file/{path}`
                .replace(`{${"path"}}`, encodeURIComponent(String(path)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary File
         * @param {string} pathOrUrl 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        fileFilePathOrUrlGet: async (pathOrUrl: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'pathOrUrl' is not null or undefined
            assertParamExists('fileFilePathOrUrlGet', 'pathOrUrl', pathOrUrl)
            const localVarPath = `/file={path_or_url}`
                .replace(`{${"path_or_url"}}`, encodeURIComponent(String(pathOrUrl)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary File
         * @param {string} pathOrUrl 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        fileFilePathOrUrlHead: async (pathOrUrl: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'pathOrUrl' is not null or undefined
            assertParamExists('fileFilePathOrUrlHead', 'pathOrUrl', pathOrUrl)
            const localVarPath = `/file={path_or_url}`
                .replace(`{${"path_or_url"}}`, encodeURIComponent(String(pathOrUrl)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'HEAD', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get Cmd Flags
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCmdFlagsSdapiV1CmdFlagsGet: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/sdapi/v1/cmd-flags`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get Config
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getConfigConfigGet: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/config`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get Config
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getConfigConfigGet_3: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/config/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get Config
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getConfigSdapiV1OptionsGet: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/sdapi/v1/options`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get Current User
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCurrentUserUserGet: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/user/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get Current User
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCurrentUserUserGet_4: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/user`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get Embeddings
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEmbeddingsSdapiV1EmbeddingsGet: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/sdapi/v1/embeddings`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get Extensions List
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getExtensionsListSdapiV1ExtensionsGet: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/sdapi/v1/extensions`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get Face Restorers
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getFaceRestorersSdapiV1FaceRestorersGet: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/sdapi/v1/face-restorers`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get Hypernetworks
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getHypernetworksSdapiV1HypernetworksGet: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/sdapi/v1/hypernetworks`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get Latent Upscale Modes
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getLatentUpscaleModesSdapiV1LatentUpscaleModesGet: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/sdapi/v1/latent-upscale-modes`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get Loras
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getLorasSdapiV1LorasGet: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/sdapi/v1/loras`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get Memory
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMemorySdapiV1MemoryGet: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/sdapi/v1/memory`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get Metadata
         * @param {string} [page] 
         * @param {string} [item] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMetadataSdExtraNetworksMetadataGet: async (page?: string, item?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/sd_extra_networks/metadata`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (item !== undefined) {
                localVarQueryParameter['item'] = item;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get Prompt Styles
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPromptStylesSdapiV1PromptStylesGet: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/sdapi/v1/prompt-styles`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get Queue Status
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getQueueStatusQueueStatusGet: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/queue/status`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get Realesrgan Models
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRealesrganModelsSdapiV1RealesrganModelsGet: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/sdapi/v1/realesrgan-models`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get Samplers
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSamplersSdapiV1SamplersGet: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/sdapi/v1/samplers`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get Script Info
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getScriptInfoSdapiV1ScriptInfoGet: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/sdapi/v1/script-info`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get Scripts List
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getScriptsListSdapiV1ScriptsGet: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/sdapi/v1/scripts`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get Sd Models
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSdModelsSdapiV1SdModelsGet: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/sdapi/v1/sd-models`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get Sd Vaes
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSdVaesSdapiV1SdVaeGet: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/sdapi/v1/sd-vae`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get Single Card
         * @param {string} [page] 
         * @param {string} [tabname] 
         * @param {string} [name] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSingleCardSdExtraNetworksGetSingleCardGet: async (page?: string, tabname?: string, name?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/sd_extra_networks/get-single-card`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (tabname !== undefined) {
                localVarQueryParameter['tabname'] = tabname;
            }

            if (name !== undefined) {
                localVarQueryParameter['name'] = name;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get Token
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTokenTokenGet: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/token/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get Token
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTokenTokenGet_5: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/token`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get Upscalers
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUpscalersSdapiV1UpscalersGet: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/sdapi/v1/upscalers`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Img2Imgapi
         * @param {StableDiffusionProcessingImg2Img} stableDiffusionProcessingImg2Img 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        img2imgapiSdapiV1Img2imgPost: async (stableDiffusionProcessingImg2Img: StableDiffusionProcessingImg2Img, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'stableDiffusionProcessingImg2Img' is not null or undefined
            assertParamExists('img2imgapiSdapiV1Img2imgPost', 'stableDiffusionProcessingImg2Img', stableDiffusionProcessingImg2Img)
            const localVarPath = `/sdapi/v1/img2img`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(stableDiffusionProcessingImg2Img, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Interrogateapi
         * @param {InterrogateRequest} interrogateRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        interrogateapiSdapiV1InterrogatePost: async (interrogateRequest: InterrogateRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'interrogateRequest' is not null or undefined
            assertParamExists('interrogateapiSdapiV1InterrogatePost', 'interrogateRequest', interrogateRequest)
            const localVarPath = `/sdapi/v1/interrogate`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(interrogateRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Interruptapi
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        interruptapiSdapiV1InterruptPost: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/sdapi/v1/interrupt`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary <Lambda>
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        lambdaInternalPingGet: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/internal/ping`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary <Lambda>
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        lambdaInternalProfileStartupGet: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/internal/profile-startup`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary <Lambda>
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        lambdaInternalSysinfoDownloadGet: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/internal/sysinfo-download`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Login Check
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        loginCheckLoginCheckGet: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/login_check/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Login Check
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        loginCheckLoginCheckGet_6: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/login_check`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Login
         * @param {string} username 
         * @param {string} password 
         * @param {string} [grantType] 
         * @param {string} [scope] 
         * @param {string} [clientId] 
         * @param {string} [clientSecret] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        loginLoginPost: async (username: string, password: string, grantType?: string, scope?: string, clientId?: string, clientSecret?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'username' is not null or undefined
            assertParamExists('loginLoginPost', 'username', username)
            // verify required parameter 'password' is not null or undefined
            assertParamExists('loginLoginPost', 'password', password)
            const localVarPath = `/login/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            const localVarFormParams = new URLSearchParams();


            if (grantType !== undefined) { 
                localVarFormParams.set('grant_type', grantType as any);
            }
    
            if (username !== undefined) { 
                localVarFormParams.set('username', username as any);
            }
    
            if (password !== undefined) { 
                localVarFormParams.set('password', password as any);
            }
    
            if (scope !== undefined) { 
                localVarFormParams.set('scope', scope as any);
            }
    
            if (clientId !== undefined) { 
                localVarFormParams.set('client_id', clientId as any);
            }
    
            if (clientSecret !== undefined) { 
                localVarFormParams.set('client_secret', clientSecret as any);
            }
    
    
            localVarHeaderParameter['Content-Type'] = 'application/x-www-form-urlencoded';
    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = localVarFormParams.toString();

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Login
         * @param {string} username 
         * @param {string} password 
         * @param {string} [grantType] 
         * @param {string} [scope] 
         * @param {string} [clientId] 
         * @param {string} [clientSecret] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        loginLoginPost_7: async (username: string, password: string, grantType?: string, scope?: string, clientId?: string, clientSecret?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'username' is not null or undefined
            assertParamExists('loginLoginPost_7', 'username', username)
            // verify required parameter 'password' is not null or undefined
            assertParamExists('loginLoginPost_7', 'password', password)
            const localVarPath = `/login`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            const localVarFormParams = new URLSearchParams();


            if (grantType !== undefined) { 
                localVarFormParams.set('grant_type', grantType as any);
            }
    
            if (username !== undefined) { 
                localVarFormParams.set('username', username as any);
            }
    
            if (password !== undefined) { 
                localVarFormParams.set('password', password as any);
            }
    
            if (scope !== undefined) { 
                localVarFormParams.set('scope', scope as any);
            }
    
            if (clientId !== undefined) { 
                localVarFormParams.set('client_id', clientId as any);
            }
    
            if (clientSecret !== undefined) { 
                localVarFormParams.set('client_secret', clientSecret as any);
            }
    
    
            localVarHeaderParameter['Content-Type'] = 'application/x-www-form-urlencoded';
    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = localVarFormParams.toString();

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Main
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        mainGet: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Main
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        mainHead: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'HEAD', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Pnginfoapi
         * @param {PNGInfoRequest} pNGInfoRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        pnginfoapiSdapiV1PngInfoPost: async (pNGInfoRequest: PNGInfoRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'pNGInfoRequest' is not null or undefined
            assertParamExists('pnginfoapiSdapiV1PngInfoPost', 'pNGInfoRequest', pNGInfoRequest)
            const localVarPath = `/sdapi/v1/png-info`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(pNGInfoRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Predict
         * @param {string} apiName 
         * @param {PredictBody} predictBody 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        predictApiApiNamePost: async (apiName: string, predictBody: PredictBody, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'apiName' is not null or undefined
            assertParamExists('predictApiApiNamePost', 'apiName', apiName)
            // verify required parameter 'predictBody' is not null or undefined
            assertParamExists('predictApiApiNamePost', 'predictBody', predictBody)
            const localVarPath = `/api/{api_name}/`
                .replace(`{${"api_name"}}`, encodeURIComponent(String(apiName)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(predictBody, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Predict
         * @param {string} apiName 
         * @param {PredictBody} predictBody 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        predictApiApiNamePost_8: async (apiName: string, predictBody: PredictBody, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'apiName' is not null or undefined
            assertParamExists('predictApiApiNamePost_8', 'apiName', apiName)
            // verify required parameter 'predictBody' is not null or undefined
            assertParamExists('predictApiApiNamePost_8', 'predictBody', predictBody)
            const localVarPath = `/api/{api_name}`
                .replace(`{${"api_name"}}`, encodeURIComponent(String(apiName)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(predictBody, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Predict
         * @param {string} apiName 
         * @param {PredictBody} predictBody 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        predictRunApiNamePost: async (apiName: string, predictBody: PredictBody, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'apiName' is not null or undefined
            assertParamExists('predictRunApiNamePost', 'apiName', apiName)
            // verify required parameter 'predictBody' is not null or undefined
            assertParamExists('predictRunApiNamePost', 'predictBody', predictBody)
            const localVarPath = `/run/{api_name}/`
                .replace(`{${"api_name"}}`, encodeURIComponent(String(apiName)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(predictBody, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Predict
         * @param {string} apiName 
         * @param {PredictBody} predictBody 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        predictRunApiNamePost_9: async (apiName: string, predictBody: PredictBody, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'apiName' is not null or undefined
            assertParamExists('predictRunApiNamePost_9', 'apiName', apiName)
            // verify required parameter 'predictBody' is not null or undefined
            assertParamExists('predictRunApiNamePost_9', 'predictBody', predictBody)
            const localVarPath = `/run/{api_name}`
                .replace(`{${"api_name"}}`, encodeURIComponent(String(apiName)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(predictBody, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Progressapi
         * @param {ProgressRequest} progressRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        progressapiInternalProgressPost: async (progressRequest: ProgressRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'progressRequest' is not null or undefined
            assertParamExists('progressapiInternalProgressPost', 'progressRequest', progressRequest)
            const localVarPath = `/internal/progress`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(progressRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Progressapi
         * @param {boolean} [skipCurrentImage] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        progressapiSdapiV1ProgressGet: async (skipCurrentImage?: boolean, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/sdapi/v1/progress`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (skipCurrentImage !== undefined) {
                localVarQueryParameter['skip_current_image'] = skipCurrentImage;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Quicksettings Hint
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        quicksettingsHintInternalQuicksettingsHintGet: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/internal/quicksettings-hint`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Refresh Checkpoints
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        refreshCheckpointsSdapiV1RefreshCheckpointsPost: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/sdapi/v1/refresh-checkpoints`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Refresh Loras
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        refreshLorasSdapiV1RefreshLorasPost: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/sdapi/v1/refresh-loras`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Refresh Vae
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        refreshVaeSdapiV1RefreshVaePost: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/sdapi/v1/refresh-vae`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Reloadapi
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        reloadapiSdapiV1ReloadCheckpointPost: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/sdapi/v1/reload-checkpoint`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Reset Iterator
         * @param {ResetBody} resetBody 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        resetIteratorResetPost: async (resetBody: ResetBody, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'resetBody' is not null or undefined
            assertParamExists('resetIteratorResetPost', 'resetBody', resetBody)
            const localVarPath = `/reset`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(resetBody, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Reset Iterator
         * @param {ResetBody} resetBody 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        resetIteratorResetPost_10: async (resetBody: ResetBody, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'resetBody' is not null or undefined
            assertParamExists('resetIteratorResetPost_10', 'resetBody', resetBody)
            const localVarPath = `/reset/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(resetBody, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Reverse Proxy
         * @param {string} urlPath 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        reverseProxyProxyUrlPathGet: async (urlPath: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'urlPath' is not null or undefined
            assertParamExists('reverseProxyProxyUrlPathGet', 'urlPath', urlPath)
            const localVarPath = `/proxy={url_path}`
                .replace(`{${"url_path"}}`, encodeURIComponent(String(urlPath)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Reverse Proxy
         * @param {string} urlPath 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        reverseProxyProxyUrlPathHead: async (urlPath: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'urlPath' is not null or undefined
            assertParamExists('reverseProxyProxyUrlPathHead', 'urlPath', urlPath)
            const localVarPath = `/proxy={url_path}`
                .replace(`{${"url_path"}}`, encodeURIComponent(String(urlPath)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'HEAD', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Robots Txt
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        robotsTxtRobotsTxtGet: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/robots.txt`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Set Config
         * @param {object} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        setConfigSdapiV1OptionsPost: async (body: object, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'body' is not null or undefined
            assertParamExists('setConfigSdapiV1OptionsPost', 'body', body)
            const localVarPath = `/sdapi/v1/options`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Skip
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        skipSdapiV1SkipPost: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/sdapi/v1/skip`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Startup Events
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        startupEventsStartupEventsGet: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/startup-events`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Static Resource
         * @param {string} path 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        staticResourceStaticPathGet: async (path: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'path' is not null or undefined
            assertParamExists('staticResourceStaticPathGet', 'path', path)
            const localVarPath = `/static/{path}`
                .replace(`{${"path"}}`, encodeURIComponent(String(path)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Stream
         * @param {string} sessionHash 
         * @param {number} run 
         * @param {number} componentId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        streamStreamSessionHashRunComponentIdGet: async (sessionHash: string, run: number, componentId: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'sessionHash' is not null or undefined
            assertParamExists('streamStreamSessionHashRunComponentIdGet', 'sessionHash', sessionHash)
            // verify required parameter 'run' is not null or undefined
            assertParamExists('streamStreamSessionHashRunComponentIdGet', 'run', run)
            // verify required parameter 'componentId' is not null or undefined
            assertParamExists('streamStreamSessionHashRunComponentIdGet', 'componentId', componentId)
            const localVarPath = `/stream/{session_hash}/{run}/{component_id}`
                .replace(`{${"session_hash"}}`, encodeURIComponent(String(sessionHash)))
                .replace(`{${"run"}}`, encodeURIComponent(String(run)))
                .replace(`{${"component_id"}}`, encodeURIComponent(String(componentId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Text2Imgapi
         * @param {StableDiffusionProcessingTxt2Img} stableDiffusionProcessingTxt2Img 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        text2imgapiSdapiV1Txt2imgPost: async (stableDiffusionProcessingTxt2Img: StableDiffusionProcessingTxt2Img, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'stableDiffusionProcessingTxt2Img' is not null or undefined
            assertParamExists('text2imgapiSdapiV1Txt2imgPost', 'stableDiffusionProcessingTxt2Img', stableDiffusionProcessingTxt2Img)
            const localVarPath = `/sdapi/v1/txt2img`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(stableDiffusionProcessingTxt2Img, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Theme Css
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        themeCssThemeCssGet: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/theme.css`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Train Embedding
         * @param {object} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        trainEmbeddingSdapiV1TrainEmbeddingPost: async (body: object, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'body' is not null or undefined
            assertParamExists('trainEmbeddingSdapiV1TrainEmbeddingPost', 'body', body)
            const localVarPath = `/sdapi/v1/train/embedding`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Train Hypernetwork
         * @param {object} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        trainHypernetworkSdapiV1TrainHypernetworkPost: async (body: object, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'body' is not null or undefined
            assertParamExists('trainHypernetworkSdapiV1TrainHypernetworkPost', 'body', body)
            const localVarPath = `/sdapi/v1/train/hypernetwork`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Unloadapi
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        unloadapiSdapiV1UnloadCheckpointPost: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/sdapi/v1/unload-checkpoint`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Upload File
         * @param {Array<File>} files 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        uploadFileUploadPost: async (files: Array<File>, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'files' is not null or undefined
            assertParamExists('uploadFileUploadPost', 'files', files)
            const localVarPath = `/upload`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            const localVarFormParams = new ((configuration && configuration.formDataCtor) || FormData)();

            if (files) {
                files.forEach((element) => {
                    localVarFormParams.append('files', element as any);
                })
            }

    
    
            localVarHeaderParameter['Content-Type'] = 'multipart/form-data';
    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = localVarFormParams;

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * DefaultApi - functional programming interface
 * @export
 */
export const DefaultApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = DefaultApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Api Info
         * @param {boolean} [serialize] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiInfoInfoGet(serialize?: boolean, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiInfoInfoGet(serialize, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['DefaultApi.apiInfoInfoGet']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * 
         * @summary Api Info
         * @param {boolean} [serialize] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiInfoInfoGet_1(serialize?: boolean, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiInfoInfoGet_1(serialize, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['DefaultApi.apiInfoInfoGet_1']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * 
         * @summary App Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async appIdAppIdGet(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.appIdAppIdGet(options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['DefaultApi.appIdAppIdGet']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * 
         * @summary App Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async appIdAppIdGet_2(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.appIdAppIdGet_2(options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['DefaultApi.appIdAppIdGet_2']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * 
         * @summary Build Resource
         * @param {string} path 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async buildResourceAssetsPathGet(path: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.buildResourceAssetsPathGet(path, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['DefaultApi.buildResourceAssetsPathGet']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * 
         * @summary Create Embedding
         * @param {object} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createEmbeddingSdapiV1CreateEmbeddingPost(body: object, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CreateResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createEmbeddingSdapiV1CreateEmbeddingPost(body, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['DefaultApi.createEmbeddingSdapiV1CreateEmbeddingPost']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * 
         * @summary Create Hypernetwork
         * @param {object} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createHypernetworkSdapiV1CreateHypernetworkPost(body: object, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CreateResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createHypernetworkSdapiV1CreateHypernetworkPost(body, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['DefaultApi.createHypernetworkSdapiV1CreateHypernetworkPost']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * 
         * @summary Download Sysinfo
         * @param {any} [attachment] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async downloadSysinfoInternalSysinfoGet(attachment?: any, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.downloadSysinfoInternalSysinfoGet(attachment, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['DefaultApi.downloadSysinfoInternalSysinfoGet']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * 
         * @summary Extras Batch Images Api
         * @param {ExtrasBatchImagesRequest} extrasBatchImagesRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async extrasBatchImagesApiSdapiV1ExtraBatchImagesPost(extrasBatchImagesRequest: ExtrasBatchImagesRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ExtrasBatchImagesResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.extrasBatchImagesApiSdapiV1ExtraBatchImagesPost(extrasBatchImagesRequest, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['DefaultApi.extrasBatchImagesApiSdapiV1ExtraBatchImagesPost']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * 
         * @summary Extras Single Image Api
         * @param {ExtrasSingleImageRequest} extrasSingleImageRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async extrasSingleImageApiSdapiV1ExtraSingleImagePost(extrasSingleImageRequest: ExtrasSingleImageRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ExtrasSingleImageResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.extrasSingleImageApiSdapiV1ExtraSingleImagePost(extrasSingleImageRequest, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['DefaultApi.extrasSingleImageApiSdapiV1ExtraSingleImagePost']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * 
         * @summary Favicon
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async faviconFaviconIcoGet(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.faviconFaviconIcoGet(options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['DefaultApi.faviconFaviconIcoGet']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * 
         * @summary Fetch File
         * @param {string} [filename] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async fetchFileSdExtraNetworksThumbGet(filename?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.fetchFileSdExtraNetworksThumbGet(filename, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['DefaultApi.fetchFileSdExtraNetworksThumbGet']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * 
         * @summary File Deprecated
         * @param {string} path 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async fileDeprecatedFilePathGet(path: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.fileDeprecatedFilePathGet(path, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['DefaultApi.fileDeprecatedFilePathGet']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * 
         * @summary File
         * @param {string} pathOrUrl 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async fileFilePathOrUrlGet(pathOrUrl: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.fileFilePathOrUrlGet(pathOrUrl, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['DefaultApi.fileFilePathOrUrlGet']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * 
         * @summary File
         * @param {string} pathOrUrl 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async fileFilePathOrUrlHead(pathOrUrl: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.fileFilePathOrUrlHead(pathOrUrl, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['DefaultApi.fileFilePathOrUrlHead']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * 
         * @summary Get Cmd Flags
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getCmdFlagsSdapiV1CmdFlagsGet(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Flags>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getCmdFlagsSdapiV1CmdFlagsGet(options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['DefaultApi.getCmdFlagsSdapiV1CmdFlagsGet']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * 
         * @summary Get Config
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getConfigConfigGet(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getConfigConfigGet(options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['DefaultApi.getConfigConfigGet']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * 
         * @summary Get Config
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getConfigConfigGet_3(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getConfigConfigGet_3(options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['DefaultApi.getConfigConfigGet_3']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * 
         * @summary Get Config
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getConfigSdapiV1OptionsGet(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Options>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getConfigSdapiV1OptionsGet(options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['DefaultApi.getConfigSdapiV1OptionsGet']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * 
         * @summary Get Current User
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getCurrentUserUserGet(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getCurrentUserUserGet(options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['DefaultApi.getCurrentUserUserGet']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * 
         * @summary Get Current User
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getCurrentUserUserGet_4(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getCurrentUserUserGet_4(options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['DefaultApi.getCurrentUserUserGet_4']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * 
         * @summary Get Embeddings
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getEmbeddingsSdapiV1EmbeddingsGet(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<EmbeddingsResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getEmbeddingsSdapiV1EmbeddingsGet(options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['DefaultApi.getEmbeddingsSdapiV1EmbeddingsGet']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * 
         * @summary Get Extensions List
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getExtensionsListSdapiV1ExtensionsGet(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<ExtensionItem>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getExtensionsListSdapiV1ExtensionsGet(options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['DefaultApi.getExtensionsListSdapiV1ExtensionsGet']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * 
         * @summary Get Face Restorers
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getFaceRestorersSdapiV1FaceRestorersGet(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<FaceRestorerItem>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getFaceRestorersSdapiV1FaceRestorersGet(options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['DefaultApi.getFaceRestorersSdapiV1FaceRestorersGet']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * 
         * @summary Get Hypernetworks
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getHypernetworksSdapiV1HypernetworksGet(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<HypernetworkItem>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getHypernetworksSdapiV1HypernetworksGet(options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['DefaultApi.getHypernetworksSdapiV1HypernetworksGet']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * 
         * @summary Get Latent Upscale Modes
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getLatentUpscaleModesSdapiV1LatentUpscaleModesGet(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<LatentUpscalerModeItem>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getLatentUpscaleModesSdapiV1LatentUpscaleModesGet(options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['DefaultApi.getLatentUpscaleModesSdapiV1LatentUpscaleModesGet']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * 
         * @summary Get Loras
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getLorasSdapiV1LorasGet(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getLorasSdapiV1LorasGet(options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['DefaultApi.getLorasSdapiV1LorasGet']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * 
         * @summary Get Memory
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getMemorySdapiV1MemoryGet(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<MemoryResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getMemorySdapiV1MemoryGet(options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['DefaultApi.getMemorySdapiV1MemoryGet']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * 
         * @summary Get Metadata
         * @param {string} [page] 
         * @param {string} [item] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getMetadataSdExtraNetworksMetadataGet(page?: string, item?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getMetadataSdExtraNetworksMetadataGet(page, item, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['DefaultApi.getMetadataSdExtraNetworksMetadataGet']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * 
         * @summary Get Prompt Styles
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getPromptStylesSdapiV1PromptStylesGet(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<PromptStyleItem>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getPromptStylesSdapiV1PromptStylesGet(options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['DefaultApi.getPromptStylesSdapiV1PromptStylesGet']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * 
         * @summary Get Queue Status
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getQueueStatusQueueStatusGet(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Estimation>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getQueueStatusQueueStatusGet(options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['DefaultApi.getQueueStatusQueueStatusGet']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * 
         * @summary Get Realesrgan Models
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getRealesrganModelsSdapiV1RealesrganModelsGet(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<RealesrganItem>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getRealesrganModelsSdapiV1RealesrganModelsGet(options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['DefaultApi.getRealesrganModelsSdapiV1RealesrganModelsGet']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * 
         * @summary Get Samplers
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getSamplersSdapiV1SamplersGet(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<SamplerItem>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getSamplersSdapiV1SamplersGet(options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['DefaultApi.getSamplersSdapiV1SamplersGet']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * 
         * @summary Get Script Info
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getScriptInfoSdapiV1ScriptInfoGet(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<ScriptInfo>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getScriptInfoSdapiV1ScriptInfoGet(options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['DefaultApi.getScriptInfoSdapiV1ScriptInfoGet']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * 
         * @summary Get Scripts List
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getScriptsListSdapiV1ScriptsGet(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ScriptsList>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getScriptsListSdapiV1ScriptsGet(options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['DefaultApi.getScriptsListSdapiV1ScriptsGet']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * 
         * @summary Get Sd Models
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getSdModelsSdapiV1SdModelsGet(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<SDModelItem>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getSdModelsSdapiV1SdModelsGet(options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['DefaultApi.getSdModelsSdapiV1SdModelsGet']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * 
         * @summary Get Sd Vaes
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getSdVaesSdapiV1SdVaeGet(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<SDVaeItem>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getSdVaesSdapiV1SdVaeGet(options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['DefaultApi.getSdVaesSdapiV1SdVaeGet']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * 
         * @summary Get Single Card
         * @param {string} [page] 
         * @param {string} [tabname] 
         * @param {string} [name] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getSingleCardSdExtraNetworksGetSingleCardGet(page?: string, tabname?: string, name?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getSingleCardSdExtraNetworksGetSingleCardGet(page, tabname, name, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['DefaultApi.getSingleCardSdExtraNetworksGetSingleCardGet']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * 
         * @summary Get Token
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getTokenTokenGet(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getTokenTokenGet(options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['DefaultApi.getTokenTokenGet']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * 
         * @summary Get Token
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getTokenTokenGet_5(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getTokenTokenGet_5(options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['DefaultApi.getTokenTokenGet_5']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * 
         * @summary Get Upscalers
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getUpscalersSdapiV1UpscalersGet(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<UpscalerItem>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getUpscalersSdapiV1UpscalersGet(options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['DefaultApi.getUpscalersSdapiV1UpscalersGet']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * 
         * @summary Img2Imgapi
         * @param {StableDiffusionProcessingImg2Img} stableDiffusionProcessingImg2Img 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async img2imgapiSdapiV1Img2imgPost(stableDiffusionProcessingImg2Img: StableDiffusionProcessingImg2Img, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ImageToImageResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.img2imgapiSdapiV1Img2imgPost(stableDiffusionProcessingImg2Img, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['DefaultApi.img2imgapiSdapiV1Img2imgPost']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * 
         * @summary Interrogateapi
         * @param {InterrogateRequest} interrogateRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async interrogateapiSdapiV1InterrogatePost(interrogateRequest: InterrogateRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.interrogateapiSdapiV1InterrogatePost(interrogateRequest, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['DefaultApi.interrogateapiSdapiV1InterrogatePost']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * 
         * @summary Interruptapi
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async interruptapiSdapiV1InterruptPost(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.interruptapiSdapiV1InterruptPost(options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['DefaultApi.interruptapiSdapiV1InterruptPost']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * 
         * @summary <Lambda>
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async lambdaInternalPingGet(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.lambdaInternalPingGet(options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['DefaultApi.lambdaInternalPingGet']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * 
         * @summary <Lambda>
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async lambdaInternalProfileStartupGet(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.lambdaInternalProfileStartupGet(options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['DefaultApi.lambdaInternalProfileStartupGet']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * 
         * @summary <Lambda>
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async lambdaInternalSysinfoDownloadGet(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.lambdaInternalSysinfoDownloadGet(options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['DefaultApi.lambdaInternalSysinfoDownloadGet']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * 
         * @summary Login Check
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async loginCheckLoginCheckGet(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.loginCheckLoginCheckGet(options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['DefaultApi.loginCheckLoginCheckGet']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * 
         * @summary Login Check
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async loginCheckLoginCheckGet_6(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.loginCheckLoginCheckGet_6(options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['DefaultApi.loginCheckLoginCheckGet_6']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * 
         * @summary Login
         * @param {string} username 
         * @param {string} password 
         * @param {string} [grantType] 
         * @param {string} [scope] 
         * @param {string} [clientId] 
         * @param {string} [clientSecret] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async loginLoginPost(username: string, password: string, grantType?: string, scope?: string, clientId?: string, clientSecret?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.loginLoginPost(username, password, grantType, scope, clientId, clientSecret, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['DefaultApi.loginLoginPost']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * 
         * @summary Login
         * @param {string} username 
         * @param {string} password 
         * @param {string} [grantType] 
         * @param {string} [scope] 
         * @param {string} [clientId] 
         * @param {string} [clientSecret] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async loginLoginPost_7(username: string, password: string, grantType?: string, scope?: string, clientId?: string, clientSecret?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.loginLoginPost_7(username, password, grantType, scope, clientId, clientSecret, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['DefaultApi.loginLoginPost_7']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * 
         * @summary Main
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async mainGet(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.mainGet(options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['DefaultApi.mainGet']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * 
         * @summary Main
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async mainHead(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.mainHead(options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['DefaultApi.mainHead']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * 
         * @summary Pnginfoapi
         * @param {PNGInfoRequest} pNGInfoRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async pnginfoapiSdapiV1PngInfoPost(pNGInfoRequest: PNGInfoRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PNGInfoResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.pnginfoapiSdapiV1PngInfoPost(pNGInfoRequest, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['DefaultApi.pnginfoapiSdapiV1PngInfoPost']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * 
         * @summary Predict
         * @param {string} apiName 
         * @param {PredictBody} predictBody 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async predictApiApiNamePost(apiName: string, predictBody: PredictBody, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.predictApiApiNamePost(apiName, predictBody, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['DefaultApi.predictApiApiNamePost']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * 
         * @summary Predict
         * @param {string} apiName 
         * @param {PredictBody} predictBody 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async predictApiApiNamePost_8(apiName: string, predictBody: PredictBody, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.predictApiApiNamePost_8(apiName, predictBody, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['DefaultApi.predictApiApiNamePost_8']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * 
         * @summary Predict
         * @param {string} apiName 
         * @param {PredictBody} predictBody 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async predictRunApiNamePost(apiName: string, predictBody: PredictBody, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.predictRunApiNamePost(apiName, predictBody, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['DefaultApi.predictRunApiNamePost']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * 
         * @summary Predict
         * @param {string} apiName 
         * @param {PredictBody} predictBody 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async predictRunApiNamePost_9(apiName: string, predictBody: PredictBody, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.predictRunApiNamePost_9(apiName, predictBody, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['DefaultApi.predictRunApiNamePost_9']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * 
         * @summary Progressapi
         * @param {ProgressRequest} progressRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async progressapiInternalProgressPost(progressRequest: ProgressRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ModulesProgressProgressResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.progressapiInternalProgressPost(progressRequest, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['DefaultApi.progressapiInternalProgressPost']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * 
         * @summary Progressapi
         * @param {boolean} [skipCurrentImage] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async progressapiSdapiV1ProgressGet(skipCurrentImage?: boolean, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ModulesApiModelsProgressResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.progressapiSdapiV1ProgressGet(skipCurrentImage, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['DefaultApi.progressapiSdapiV1ProgressGet']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * 
         * @summary Quicksettings Hint
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async quicksettingsHintInternalQuicksettingsHintGet(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<QuicksettingsHint>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.quicksettingsHintInternalQuicksettingsHintGet(options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['DefaultApi.quicksettingsHintInternalQuicksettingsHintGet']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * 
         * @summary Refresh Checkpoints
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async refreshCheckpointsSdapiV1RefreshCheckpointsPost(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.refreshCheckpointsSdapiV1RefreshCheckpointsPost(options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['DefaultApi.refreshCheckpointsSdapiV1RefreshCheckpointsPost']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * 
         * @summary Refresh Loras
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async refreshLorasSdapiV1RefreshLorasPost(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.refreshLorasSdapiV1RefreshLorasPost(options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['DefaultApi.refreshLorasSdapiV1RefreshLorasPost']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * 
         * @summary Refresh Vae
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async refreshVaeSdapiV1RefreshVaePost(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.refreshVaeSdapiV1RefreshVaePost(options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['DefaultApi.refreshVaeSdapiV1RefreshVaePost']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * 
         * @summary Reloadapi
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async reloadapiSdapiV1ReloadCheckpointPost(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.reloadapiSdapiV1ReloadCheckpointPost(options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['DefaultApi.reloadapiSdapiV1ReloadCheckpointPost']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * 
         * @summary Reset Iterator
         * @param {ResetBody} resetBody 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async resetIteratorResetPost(resetBody: ResetBody, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.resetIteratorResetPost(resetBody, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['DefaultApi.resetIteratorResetPost']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * 
         * @summary Reset Iterator
         * @param {ResetBody} resetBody 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async resetIteratorResetPost_10(resetBody: ResetBody, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.resetIteratorResetPost_10(resetBody, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['DefaultApi.resetIteratorResetPost_10']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * 
         * @summary Reverse Proxy
         * @param {string} urlPath 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async reverseProxyProxyUrlPathGet(urlPath: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.reverseProxyProxyUrlPathGet(urlPath, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['DefaultApi.reverseProxyProxyUrlPathGet']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * 
         * @summary Reverse Proxy
         * @param {string} urlPath 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async reverseProxyProxyUrlPathHead(urlPath: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.reverseProxyProxyUrlPathHead(urlPath, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['DefaultApi.reverseProxyProxyUrlPathHead']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * 
         * @summary Robots Txt
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async robotsTxtRobotsTxtGet(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.robotsTxtRobotsTxtGet(options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['DefaultApi.robotsTxtRobotsTxtGet']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * 
         * @summary Set Config
         * @param {object} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async setConfigSdapiV1OptionsPost(body: object, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.setConfigSdapiV1OptionsPost(body, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['DefaultApi.setConfigSdapiV1OptionsPost']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * 
         * @summary Skip
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async skipSdapiV1SkipPost(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.skipSdapiV1SkipPost(options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['DefaultApi.skipSdapiV1SkipPost']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * 
         * @summary Startup Events
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async startupEventsStartupEventsGet(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.startupEventsStartupEventsGet(options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['DefaultApi.startupEventsStartupEventsGet']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * 
         * @summary Static Resource
         * @param {string} path 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async staticResourceStaticPathGet(path: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.staticResourceStaticPathGet(path, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['DefaultApi.staticResourceStaticPathGet']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * 
         * @summary Stream
         * @param {string} sessionHash 
         * @param {number} run 
         * @param {number} componentId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async streamStreamSessionHashRunComponentIdGet(sessionHash: string, run: number, componentId: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.streamStreamSessionHashRunComponentIdGet(sessionHash, run, componentId, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['DefaultApi.streamStreamSessionHashRunComponentIdGet']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * 
         * @summary Text2Imgapi
         * @param {StableDiffusionProcessingTxt2Img} stableDiffusionProcessingTxt2Img 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async text2imgapiSdapiV1Txt2imgPost(stableDiffusionProcessingTxt2Img: StableDiffusionProcessingTxt2Img, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TextToImageResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.text2imgapiSdapiV1Txt2imgPost(stableDiffusionProcessingTxt2Img, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['DefaultApi.text2imgapiSdapiV1Txt2imgPost']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * 
         * @summary Theme Css
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async themeCssThemeCssGet(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.themeCssThemeCssGet(options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['DefaultApi.themeCssThemeCssGet']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * 
         * @summary Train Embedding
         * @param {object} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async trainEmbeddingSdapiV1TrainEmbeddingPost(body: object, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TrainResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.trainEmbeddingSdapiV1TrainEmbeddingPost(body, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['DefaultApi.trainEmbeddingSdapiV1TrainEmbeddingPost']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * 
         * @summary Train Hypernetwork
         * @param {object} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async trainHypernetworkSdapiV1TrainHypernetworkPost(body: object, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TrainResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.trainHypernetworkSdapiV1TrainHypernetworkPost(body, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['DefaultApi.trainHypernetworkSdapiV1TrainHypernetworkPost']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * 
         * @summary Unloadapi
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async unloadapiSdapiV1UnloadCheckpointPost(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.unloadapiSdapiV1UnloadCheckpointPost(options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['DefaultApi.unloadapiSdapiV1UnloadCheckpointPost']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * 
         * @summary Upload File
         * @param {Array<File>} files 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async uploadFileUploadPost(files: Array<File>, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.uploadFileUploadPost(files, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['DefaultApi.uploadFileUploadPost']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
    }
};

/**
 * DefaultApi - factory interface
 * @export
 */
export const DefaultApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = DefaultApiFp(configuration)
    return {
        /**
         * 
         * @summary Api Info
         * @param {boolean} [serialize] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiInfoInfoGet(serialize?: boolean, options?: any): AxiosPromise<any> {
            return localVarFp.apiInfoInfoGet(serialize, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Api Info
         * @param {boolean} [serialize] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiInfoInfoGet_1(serialize?: boolean, options?: any): AxiosPromise<any> {
            return localVarFp.apiInfoInfoGet_1(serialize, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary App Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        appIdAppIdGet(options?: any): AxiosPromise<object> {
            return localVarFp.appIdAppIdGet(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary App Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        appIdAppIdGet_2(options?: any): AxiosPromise<object> {
            return localVarFp.appIdAppIdGet_2(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Build Resource
         * @param {string} path 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        buildResourceAssetsPathGet(path: string, options?: any): AxiosPromise<any> {
            return localVarFp.buildResourceAssetsPathGet(path, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Create Embedding
         * @param {object} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createEmbeddingSdapiV1CreateEmbeddingPost(body: object, options?: any): AxiosPromise<CreateResponse> {
            return localVarFp.createEmbeddingSdapiV1CreateEmbeddingPost(body, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Create Hypernetwork
         * @param {object} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createHypernetworkSdapiV1CreateHypernetworkPost(body: object, options?: any): AxiosPromise<CreateResponse> {
            return localVarFp.createHypernetworkSdapiV1CreateHypernetworkPost(body, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Download Sysinfo
         * @param {any} [attachment] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        downloadSysinfoInternalSysinfoGet(attachment?: any, options?: any): AxiosPromise<any> {
            return localVarFp.downloadSysinfoInternalSysinfoGet(attachment, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Extras Batch Images Api
         * @param {ExtrasBatchImagesRequest} extrasBatchImagesRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        extrasBatchImagesApiSdapiV1ExtraBatchImagesPost(extrasBatchImagesRequest: ExtrasBatchImagesRequest, options?: any): AxiosPromise<ExtrasBatchImagesResponse> {
            return localVarFp.extrasBatchImagesApiSdapiV1ExtraBatchImagesPost(extrasBatchImagesRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Extras Single Image Api
         * @param {ExtrasSingleImageRequest} extrasSingleImageRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        extrasSingleImageApiSdapiV1ExtraSingleImagePost(extrasSingleImageRequest: ExtrasSingleImageRequest, options?: any): AxiosPromise<ExtrasSingleImageResponse> {
            return localVarFp.extrasSingleImageApiSdapiV1ExtraSingleImagePost(extrasSingleImageRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Favicon
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        faviconFaviconIcoGet(options?: any): AxiosPromise<any> {
            return localVarFp.faviconFaviconIcoGet(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Fetch File
         * @param {string} [filename] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        fetchFileSdExtraNetworksThumbGet(filename?: string, options?: any): AxiosPromise<any> {
            return localVarFp.fetchFileSdExtraNetworksThumbGet(filename, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary File Deprecated
         * @param {string} path 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        fileDeprecatedFilePathGet(path: string, options?: any): AxiosPromise<any> {
            return localVarFp.fileDeprecatedFilePathGet(path, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary File
         * @param {string} pathOrUrl 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        fileFilePathOrUrlGet(pathOrUrl: string, options?: any): AxiosPromise<any> {
            return localVarFp.fileFilePathOrUrlGet(pathOrUrl, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary File
         * @param {string} pathOrUrl 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        fileFilePathOrUrlHead(pathOrUrl: string, options?: any): AxiosPromise<any> {
            return localVarFp.fileFilePathOrUrlHead(pathOrUrl, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get Cmd Flags
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCmdFlagsSdapiV1CmdFlagsGet(options?: any): AxiosPromise<Flags> {
            return localVarFp.getCmdFlagsSdapiV1CmdFlagsGet(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get Config
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getConfigConfigGet(options?: any): AxiosPromise<any> {
            return localVarFp.getConfigConfigGet(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get Config
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getConfigConfigGet_3(options?: any): AxiosPromise<any> {
            return localVarFp.getConfigConfigGet_3(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get Config
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getConfigSdapiV1OptionsGet(options?: any): AxiosPromise<Options> {
            return localVarFp.getConfigSdapiV1OptionsGet(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get Current User
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCurrentUserUserGet(options?: any): AxiosPromise<string> {
            return localVarFp.getCurrentUserUserGet(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get Current User
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCurrentUserUserGet_4(options?: any): AxiosPromise<string> {
            return localVarFp.getCurrentUserUserGet_4(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get Embeddings
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEmbeddingsSdapiV1EmbeddingsGet(options?: any): AxiosPromise<EmbeddingsResponse> {
            return localVarFp.getEmbeddingsSdapiV1EmbeddingsGet(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get Extensions List
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getExtensionsListSdapiV1ExtensionsGet(options?: any): AxiosPromise<Array<ExtensionItem>> {
            return localVarFp.getExtensionsListSdapiV1ExtensionsGet(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get Face Restorers
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getFaceRestorersSdapiV1FaceRestorersGet(options?: any): AxiosPromise<Array<FaceRestorerItem>> {
            return localVarFp.getFaceRestorersSdapiV1FaceRestorersGet(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get Hypernetworks
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getHypernetworksSdapiV1HypernetworksGet(options?: any): AxiosPromise<Array<HypernetworkItem>> {
            return localVarFp.getHypernetworksSdapiV1HypernetworksGet(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get Latent Upscale Modes
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getLatentUpscaleModesSdapiV1LatentUpscaleModesGet(options?: any): AxiosPromise<Array<LatentUpscalerModeItem>> {
            return localVarFp.getLatentUpscaleModesSdapiV1LatentUpscaleModesGet(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get Loras
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getLorasSdapiV1LorasGet(options?: any): AxiosPromise<any> {
            return localVarFp.getLorasSdapiV1LorasGet(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get Memory
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMemorySdapiV1MemoryGet(options?: any): AxiosPromise<MemoryResponse> {
            return localVarFp.getMemorySdapiV1MemoryGet(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get Metadata
         * @param {string} [page] 
         * @param {string} [item] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMetadataSdExtraNetworksMetadataGet(page?: string, item?: string, options?: any): AxiosPromise<any> {
            return localVarFp.getMetadataSdExtraNetworksMetadataGet(page, item, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get Prompt Styles
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPromptStylesSdapiV1PromptStylesGet(options?: any): AxiosPromise<Array<PromptStyleItem>> {
            return localVarFp.getPromptStylesSdapiV1PromptStylesGet(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get Queue Status
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getQueueStatusQueueStatusGet(options?: any): AxiosPromise<Estimation> {
            return localVarFp.getQueueStatusQueueStatusGet(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get Realesrgan Models
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRealesrganModelsSdapiV1RealesrganModelsGet(options?: any): AxiosPromise<Array<RealesrganItem>> {
            return localVarFp.getRealesrganModelsSdapiV1RealesrganModelsGet(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get Samplers
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSamplersSdapiV1SamplersGet(options?: any): AxiosPromise<Array<SamplerItem>> {
            return localVarFp.getSamplersSdapiV1SamplersGet(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get Script Info
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getScriptInfoSdapiV1ScriptInfoGet(options?: any): AxiosPromise<Array<ScriptInfo>> {
            return localVarFp.getScriptInfoSdapiV1ScriptInfoGet(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get Scripts List
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getScriptsListSdapiV1ScriptsGet(options?: any): AxiosPromise<ScriptsList> {
            return localVarFp.getScriptsListSdapiV1ScriptsGet(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get Sd Models
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSdModelsSdapiV1SdModelsGet(options?: any): AxiosPromise<Array<SDModelItem>> {
            return localVarFp.getSdModelsSdapiV1SdModelsGet(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get Sd Vaes
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSdVaesSdapiV1SdVaeGet(options?: any): AxiosPromise<Array<SDVaeItem>> {
            return localVarFp.getSdVaesSdapiV1SdVaeGet(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get Single Card
         * @param {string} [page] 
         * @param {string} [tabname] 
         * @param {string} [name] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSingleCardSdExtraNetworksGetSingleCardGet(page?: string, tabname?: string, name?: string, options?: any): AxiosPromise<any> {
            return localVarFp.getSingleCardSdExtraNetworksGetSingleCardGet(page, tabname, name, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get Token
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTokenTokenGet(options?: any): AxiosPromise<object> {
            return localVarFp.getTokenTokenGet(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get Token
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTokenTokenGet_5(options?: any): AxiosPromise<object> {
            return localVarFp.getTokenTokenGet_5(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get Upscalers
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUpscalersSdapiV1UpscalersGet(options?: any): AxiosPromise<Array<UpscalerItem>> {
            return localVarFp.getUpscalersSdapiV1UpscalersGet(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Img2Imgapi
         * @param {StableDiffusionProcessingImg2Img} stableDiffusionProcessingImg2Img 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        img2imgapiSdapiV1Img2imgPost(stableDiffusionProcessingImg2Img: StableDiffusionProcessingImg2Img, options?: any): AxiosPromise<ImageToImageResponse> {
            return localVarFp.img2imgapiSdapiV1Img2imgPost(stableDiffusionProcessingImg2Img, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Interrogateapi
         * @param {InterrogateRequest} interrogateRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        interrogateapiSdapiV1InterrogatePost(interrogateRequest: InterrogateRequest, options?: any): AxiosPromise<any> {
            return localVarFp.interrogateapiSdapiV1InterrogatePost(interrogateRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Interruptapi
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        interruptapiSdapiV1InterruptPost(options?: any): AxiosPromise<any> {
            return localVarFp.interruptapiSdapiV1InterruptPost(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary <Lambda>
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        lambdaInternalPingGet(options?: any): AxiosPromise<any> {
            return localVarFp.lambdaInternalPingGet(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary <Lambda>
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        lambdaInternalProfileStartupGet(options?: any): AxiosPromise<any> {
            return localVarFp.lambdaInternalProfileStartupGet(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary <Lambda>
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        lambdaInternalSysinfoDownloadGet(options?: any): AxiosPromise<any> {
            return localVarFp.lambdaInternalSysinfoDownloadGet(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Login Check
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        loginCheckLoginCheckGet(options?: any): AxiosPromise<any> {
            return localVarFp.loginCheckLoginCheckGet(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Login Check
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        loginCheckLoginCheckGet_6(options?: any): AxiosPromise<any> {
            return localVarFp.loginCheckLoginCheckGet_6(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Login
         * @param {string} username 
         * @param {string} password 
         * @param {string} [grantType] 
         * @param {string} [scope] 
         * @param {string} [clientId] 
         * @param {string} [clientSecret] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        loginLoginPost(username: string, password: string, grantType?: string, scope?: string, clientId?: string, clientSecret?: string, options?: any): AxiosPromise<any> {
            return localVarFp.loginLoginPost(username, password, grantType, scope, clientId, clientSecret, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Login
         * @param {string} username 
         * @param {string} password 
         * @param {string} [grantType] 
         * @param {string} [scope] 
         * @param {string} [clientId] 
         * @param {string} [clientSecret] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        loginLoginPost_7(username: string, password: string, grantType?: string, scope?: string, clientId?: string, clientSecret?: string, options?: any): AxiosPromise<any> {
            return localVarFp.loginLoginPost_7(username, password, grantType, scope, clientId, clientSecret, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Main
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        mainGet(options?: any): AxiosPromise<string> {
            return localVarFp.mainGet(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Main
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        mainHead(options?: any): AxiosPromise<string> {
            return localVarFp.mainHead(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Pnginfoapi
         * @param {PNGInfoRequest} pNGInfoRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        pnginfoapiSdapiV1PngInfoPost(pNGInfoRequest: PNGInfoRequest, options?: any): AxiosPromise<PNGInfoResponse> {
            return localVarFp.pnginfoapiSdapiV1PngInfoPost(pNGInfoRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Predict
         * @param {string} apiName 
         * @param {PredictBody} predictBody 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        predictApiApiNamePost(apiName: string, predictBody: PredictBody, options?: any): AxiosPromise<any> {
            return localVarFp.predictApiApiNamePost(apiName, predictBody, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Predict
         * @param {string} apiName 
         * @param {PredictBody} predictBody 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        predictApiApiNamePost_8(apiName: string, predictBody: PredictBody, options?: any): AxiosPromise<any> {
            return localVarFp.predictApiApiNamePost_8(apiName, predictBody, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Predict
         * @param {string} apiName 
         * @param {PredictBody} predictBody 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        predictRunApiNamePost(apiName: string, predictBody: PredictBody, options?: any): AxiosPromise<any> {
            return localVarFp.predictRunApiNamePost(apiName, predictBody, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Predict
         * @param {string} apiName 
         * @param {PredictBody} predictBody 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        predictRunApiNamePost_9(apiName: string, predictBody: PredictBody, options?: any): AxiosPromise<any> {
            return localVarFp.predictRunApiNamePost_9(apiName, predictBody, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Progressapi
         * @param {ProgressRequest} progressRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        progressapiInternalProgressPost(progressRequest: ProgressRequest, options?: any): AxiosPromise<ModulesProgressProgressResponse> {
            return localVarFp.progressapiInternalProgressPost(progressRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Progressapi
         * @param {boolean} [skipCurrentImage] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        progressapiSdapiV1ProgressGet(skipCurrentImage?: boolean, options?: any): AxiosPromise<ModulesApiModelsProgressResponse> {
            return localVarFp.progressapiSdapiV1ProgressGet(skipCurrentImage, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Quicksettings Hint
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        quicksettingsHintInternalQuicksettingsHintGet(options?: any): AxiosPromise<Array<QuicksettingsHint>> {
            return localVarFp.quicksettingsHintInternalQuicksettingsHintGet(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Refresh Checkpoints
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        refreshCheckpointsSdapiV1RefreshCheckpointsPost(options?: any): AxiosPromise<any> {
            return localVarFp.refreshCheckpointsSdapiV1RefreshCheckpointsPost(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Refresh Loras
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        refreshLorasSdapiV1RefreshLorasPost(options?: any): AxiosPromise<any> {
            return localVarFp.refreshLorasSdapiV1RefreshLorasPost(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Refresh Vae
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        refreshVaeSdapiV1RefreshVaePost(options?: any): AxiosPromise<any> {
            return localVarFp.refreshVaeSdapiV1RefreshVaePost(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Reloadapi
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        reloadapiSdapiV1ReloadCheckpointPost(options?: any): AxiosPromise<any> {
            return localVarFp.reloadapiSdapiV1ReloadCheckpointPost(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Reset Iterator
         * @param {ResetBody} resetBody 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        resetIteratorResetPost(resetBody: ResetBody, options?: any): AxiosPromise<any> {
            return localVarFp.resetIteratorResetPost(resetBody, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Reset Iterator
         * @param {ResetBody} resetBody 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        resetIteratorResetPost_10(resetBody: ResetBody, options?: any): AxiosPromise<any> {
            return localVarFp.resetIteratorResetPost_10(resetBody, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Reverse Proxy
         * @param {string} urlPath 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        reverseProxyProxyUrlPathGet(urlPath: string, options?: any): AxiosPromise<any> {
            return localVarFp.reverseProxyProxyUrlPathGet(urlPath, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Reverse Proxy
         * @param {string} urlPath 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        reverseProxyProxyUrlPathHead(urlPath: string, options?: any): AxiosPromise<any> {
            return localVarFp.reverseProxyProxyUrlPathHead(urlPath, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Robots Txt
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        robotsTxtRobotsTxtGet(options?: any): AxiosPromise<string> {
            return localVarFp.robotsTxtRobotsTxtGet(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Set Config
         * @param {object} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        setConfigSdapiV1OptionsPost(body: object, options?: any): AxiosPromise<any> {
            return localVarFp.setConfigSdapiV1OptionsPost(body, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Skip
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        skipSdapiV1SkipPost(options?: any): AxiosPromise<any> {
            return localVarFp.skipSdapiV1SkipPost(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Startup Events
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        startupEventsStartupEventsGet(options?: any): AxiosPromise<any> {
            return localVarFp.startupEventsStartupEventsGet(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Static Resource
         * @param {string} path 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        staticResourceStaticPathGet(path: string, options?: any): AxiosPromise<any> {
            return localVarFp.staticResourceStaticPathGet(path, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Stream
         * @param {string} sessionHash 
         * @param {number} run 
         * @param {number} componentId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        streamStreamSessionHashRunComponentIdGet(sessionHash: string, run: number, componentId: number, options?: any): AxiosPromise<any> {
            return localVarFp.streamStreamSessionHashRunComponentIdGet(sessionHash, run, componentId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Text2Imgapi
         * @param {StableDiffusionProcessingTxt2Img} stableDiffusionProcessingTxt2Img 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        text2imgapiSdapiV1Txt2imgPost(stableDiffusionProcessingTxt2Img: StableDiffusionProcessingTxt2Img, options?: any): AxiosPromise<TextToImageResponse> {
            return localVarFp.text2imgapiSdapiV1Txt2imgPost(stableDiffusionProcessingTxt2Img, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Theme Css
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        themeCssThemeCssGet(options?: any): AxiosPromise<string> {
            return localVarFp.themeCssThemeCssGet(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Train Embedding
         * @param {object} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        trainEmbeddingSdapiV1TrainEmbeddingPost(body: object, options?: any): AxiosPromise<TrainResponse> {
            return localVarFp.trainEmbeddingSdapiV1TrainEmbeddingPost(body, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Train Hypernetwork
         * @param {object} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        trainHypernetworkSdapiV1TrainHypernetworkPost(body: object, options?: any): AxiosPromise<TrainResponse> {
            return localVarFp.trainHypernetworkSdapiV1TrainHypernetworkPost(body, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Unloadapi
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        unloadapiSdapiV1UnloadCheckpointPost(options?: any): AxiosPromise<any> {
            return localVarFp.unloadapiSdapiV1UnloadCheckpointPost(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Upload File
         * @param {Array<File>} files 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        uploadFileUploadPost(files: Array<File>, options?: any): AxiosPromise<any> {
            return localVarFp.uploadFileUploadPost(files, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * DefaultApi - object-oriented interface
 * @export
 * @class DefaultApi
 * @extends {BaseAPI}
 */
export class DefaultApi extends BaseAPI {
    /**
     * 
     * @summary Api Info
     * @param {boolean} [serialize] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public apiInfoInfoGet(serialize?: boolean, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).apiInfoInfoGet(serialize, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Api Info
     * @param {boolean} [serialize] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public apiInfoInfoGet_1(serialize?: boolean, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).apiInfoInfoGet_1(serialize, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary App Id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public appIdAppIdGet(options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).appIdAppIdGet(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary App Id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public appIdAppIdGet_2(options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).appIdAppIdGet_2(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Build Resource
     * @param {string} path 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public buildResourceAssetsPathGet(path: string, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).buildResourceAssetsPathGet(path, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Create Embedding
     * @param {object} body 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public createEmbeddingSdapiV1CreateEmbeddingPost(body: object, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).createEmbeddingSdapiV1CreateEmbeddingPost(body, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Create Hypernetwork
     * @param {object} body 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public createHypernetworkSdapiV1CreateHypernetworkPost(body: object, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).createHypernetworkSdapiV1CreateHypernetworkPost(body, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Download Sysinfo
     * @param {any} [attachment] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public downloadSysinfoInternalSysinfoGet(attachment?: any, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).downloadSysinfoInternalSysinfoGet(attachment, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Extras Batch Images Api
     * @param {ExtrasBatchImagesRequest} extrasBatchImagesRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public extrasBatchImagesApiSdapiV1ExtraBatchImagesPost(extrasBatchImagesRequest: ExtrasBatchImagesRequest, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).extrasBatchImagesApiSdapiV1ExtraBatchImagesPost(extrasBatchImagesRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Extras Single Image Api
     * @param {ExtrasSingleImageRequest} extrasSingleImageRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public extrasSingleImageApiSdapiV1ExtraSingleImagePost(extrasSingleImageRequest: ExtrasSingleImageRequest, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).extrasSingleImageApiSdapiV1ExtraSingleImagePost(extrasSingleImageRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Favicon
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public faviconFaviconIcoGet(options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).faviconFaviconIcoGet(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Fetch File
     * @param {string} [filename] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public fetchFileSdExtraNetworksThumbGet(filename?: string, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).fetchFileSdExtraNetworksThumbGet(filename, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary File Deprecated
     * @param {string} path 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public fileDeprecatedFilePathGet(path: string, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).fileDeprecatedFilePathGet(path, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary File
     * @param {string} pathOrUrl 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public fileFilePathOrUrlGet(pathOrUrl: string, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).fileFilePathOrUrlGet(pathOrUrl, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary File
     * @param {string} pathOrUrl 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public fileFilePathOrUrlHead(pathOrUrl: string, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).fileFilePathOrUrlHead(pathOrUrl, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get Cmd Flags
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public getCmdFlagsSdapiV1CmdFlagsGet(options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).getCmdFlagsSdapiV1CmdFlagsGet(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get Config
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public getConfigConfigGet(options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).getConfigConfigGet(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get Config
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public getConfigConfigGet_3(options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).getConfigConfigGet_3(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get Config
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public getConfigSdapiV1OptionsGet(options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).getConfigSdapiV1OptionsGet(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get Current User
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public getCurrentUserUserGet(options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).getCurrentUserUserGet(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get Current User
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public getCurrentUserUserGet_4(options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).getCurrentUserUserGet_4(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get Embeddings
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public getEmbeddingsSdapiV1EmbeddingsGet(options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).getEmbeddingsSdapiV1EmbeddingsGet(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get Extensions List
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public getExtensionsListSdapiV1ExtensionsGet(options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).getExtensionsListSdapiV1ExtensionsGet(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get Face Restorers
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public getFaceRestorersSdapiV1FaceRestorersGet(options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).getFaceRestorersSdapiV1FaceRestorersGet(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get Hypernetworks
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public getHypernetworksSdapiV1HypernetworksGet(options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).getHypernetworksSdapiV1HypernetworksGet(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get Latent Upscale Modes
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public getLatentUpscaleModesSdapiV1LatentUpscaleModesGet(options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).getLatentUpscaleModesSdapiV1LatentUpscaleModesGet(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get Loras
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public getLorasSdapiV1LorasGet(options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).getLorasSdapiV1LorasGet(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get Memory
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public getMemorySdapiV1MemoryGet(options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).getMemorySdapiV1MemoryGet(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get Metadata
     * @param {string} [page] 
     * @param {string} [item] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public getMetadataSdExtraNetworksMetadataGet(page?: string, item?: string, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).getMetadataSdExtraNetworksMetadataGet(page, item, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get Prompt Styles
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public getPromptStylesSdapiV1PromptStylesGet(options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).getPromptStylesSdapiV1PromptStylesGet(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get Queue Status
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public getQueueStatusQueueStatusGet(options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).getQueueStatusQueueStatusGet(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get Realesrgan Models
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public getRealesrganModelsSdapiV1RealesrganModelsGet(options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).getRealesrganModelsSdapiV1RealesrganModelsGet(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get Samplers
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public getSamplersSdapiV1SamplersGet(options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).getSamplersSdapiV1SamplersGet(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get Script Info
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public getScriptInfoSdapiV1ScriptInfoGet(options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).getScriptInfoSdapiV1ScriptInfoGet(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get Scripts List
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public getScriptsListSdapiV1ScriptsGet(options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).getScriptsListSdapiV1ScriptsGet(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get Sd Models
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public getSdModelsSdapiV1SdModelsGet(options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).getSdModelsSdapiV1SdModelsGet(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get Sd Vaes
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public getSdVaesSdapiV1SdVaeGet(options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).getSdVaesSdapiV1SdVaeGet(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get Single Card
     * @param {string} [page] 
     * @param {string} [tabname] 
     * @param {string} [name] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public getSingleCardSdExtraNetworksGetSingleCardGet(page?: string, tabname?: string, name?: string, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).getSingleCardSdExtraNetworksGetSingleCardGet(page, tabname, name, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get Token
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public getTokenTokenGet(options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).getTokenTokenGet(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get Token
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public getTokenTokenGet_5(options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).getTokenTokenGet_5(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get Upscalers
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public getUpscalersSdapiV1UpscalersGet(options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).getUpscalersSdapiV1UpscalersGet(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Img2Imgapi
     * @param {StableDiffusionProcessingImg2Img} stableDiffusionProcessingImg2Img 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public img2imgapiSdapiV1Img2imgPost(stableDiffusionProcessingImg2Img: StableDiffusionProcessingImg2Img, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).img2imgapiSdapiV1Img2imgPost(stableDiffusionProcessingImg2Img, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Interrogateapi
     * @param {InterrogateRequest} interrogateRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public interrogateapiSdapiV1InterrogatePost(interrogateRequest: InterrogateRequest, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).interrogateapiSdapiV1InterrogatePost(interrogateRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Interruptapi
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public interruptapiSdapiV1InterruptPost(options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).interruptapiSdapiV1InterruptPost(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary <Lambda>
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public lambdaInternalPingGet(options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).lambdaInternalPingGet(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary <Lambda>
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public lambdaInternalProfileStartupGet(options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).lambdaInternalProfileStartupGet(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary <Lambda>
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public lambdaInternalSysinfoDownloadGet(options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).lambdaInternalSysinfoDownloadGet(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Login Check
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public loginCheckLoginCheckGet(options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).loginCheckLoginCheckGet(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Login Check
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public loginCheckLoginCheckGet_6(options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).loginCheckLoginCheckGet_6(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Login
     * @param {string} username 
     * @param {string} password 
     * @param {string} [grantType] 
     * @param {string} [scope] 
     * @param {string} [clientId] 
     * @param {string} [clientSecret] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public loginLoginPost(username: string, password: string, grantType?: string, scope?: string, clientId?: string, clientSecret?: string, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).loginLoginPost(username, password, grantType, scope, clientId, clientSecret, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Login
     * @param {string} username 
     * @param {string} password 
     * @param {string} [grantType] 
     * @param {string} [scope] 
     * @param {string} [clientId] 
     * @param {string} [clientSecret] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public loginLoginPost_7(username: string, password: string, grantType?: string, scope?: string, clientId?: string, clientSecret?: string, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).loginLoginPost_7(username, password, grantType, scope, clientId, clientSecret, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Main
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public mainGet(options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).mainGet(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Main
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public mainHead(options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).mainHead(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Pnginfoapi
     * @param {PNGInfoRequest} pNGInfoRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public pnginfoapiSdapiV1PngInfoPost(pNGInfoRequest: PNGInfoRequest, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).pnginfoapiSdapiV1PngInfoPost(pNGInfoRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Predict
     * @param {string} apiName 
     * @param {PredictBody} predictBody 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public predictApiApiNamePost(apiName: string, predictBody: PredictBody, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).predictApiApiNamePost(apiName, predictBody, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Predict
     * @param {string} apiName 
     * @param {PredictBody} predictBody 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public predictApiApiNamePost_8(apiName: string, predictBody: PredictBody, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).predictApiApiNamePost_8(apiName, predictBody, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Predict
     * @param {string} apiName 
     * @param {PredictBody} predictBody 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public predictRunApiNamePost(apiName: string, predictBody: PredictBody, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).predictRunApiNamePost(apiName, predictBody, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Predict
     * @param {string} apiName 
     * @param {PredictBody} predictBody 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public predictRunApiNamePost_9(apiName: string, predictBody: PredictBody, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).predictRunApiNamePost_9(apiName, predictBody, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Progressapi
     * @param {ProgressRequest} progressRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public progressapiInternalProgressPost(progressRequest: ProgressRequest, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).progressapiInternalProgressPost(progressRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Progressapi
     * @param {boolean} [skipCurrentImage] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public progressapiSdapiV1ProgressGet(skipCurrentImage?: boolean, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).progressapiSdapiV1ProgressGet(skipCurrentImage, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Quicksettings Hint
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public quicksettingsHintInternalQuicksettingsHintGet(options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).quicksettingsHintInternalQuicksettingsHintGet(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Refresh Checkpoints
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public refreshCheckpointsSdapiV1RefreshCheckpointsPost(options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).refreshCheckpointsSdapiV1RefreshCheckpointsPost(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Refresh Loras
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public refreshLorasSdapiV1RefreshLorasPost(options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).refreshLorasSdapiV1RefreshLorasPost(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Refresh Vae
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public refreshVaeSdapiV1RefreshVaePost(options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).refreshVaeSdapiV1RefreshVaePost(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Reloadapi
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public reloadapiSdapiV1ReloadCheckpointPost(options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).reloadapiSdapiV1ReloadCheckpointPost(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Reset Iterator
     * @param {ResetBody} resetBody 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public resetIteratorResetPost(resetBody: ResetBody, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).resetIteratorResetPost(resetBody, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Reset Iterator
     * @param {ResetBody} resetBody 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public resetIteratorResetPost_10(resetBody: ResetBody, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).resetIteratorResetPost_10(resetBody, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Reverse Proxy
     * @param {string} urlPath 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public reverseProxyProxyUrlPathGet(urlPath: string, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).reverseProxyProxyUrlPathGet(urlPath, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Reverse Proxy
     * @param {string} urlPath 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public reverseProxyProxyUrlPathHead(urlPath: string, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).reverseProxyProxyUrlPathHead(urlPath, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Robots Txt
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public robotsTxtRobotsTxtGet(options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).robotsTxtRobotsTxtGet(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Set Config
     * @param {object} body 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public setConfigSdapiV1OptionsPost(body: object, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).setConfigSdapiV1OptionsPost(body, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Skip
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public skipSdapiV1SkipPost(options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).skipSdapiV1SkipPost(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Startup Events
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public startupEventsStartupEventsGet(options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).startupEventsStartupEventsGet(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Static Resource
     * @param {string} path 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public staticResourceStaticPathGet(path: string, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).staticResourceStaticPathGet(path, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Stream
     * @param {string} sessionHash 
     * @param {number} run 
     * @param {number} componentId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public streamStreamSessionHashRunComponentIdGet(sessionHash: string, run: number, componentId: number, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).streamStreamSessionHashRunComponentIdGet(sessionHash, run, componentId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Text2Imgapi
     * @param {StableDiffusionProcessingTxt2Img} stableDiffusionProcessingTxt2Img 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public text2imgapiSdapiV1Txt2imgPost(stableDiffusionProcessingTxt2Img: StableDiffusionProcessingTxt2Img, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).text2imgapiSdapiV1Txt2imgPost(stableDiffusionProcessingTxt2Img, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Theme Css
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public themeCssThemeCssGet(options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).themeCssThemeCssGet(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Train Embedding
     * @param {object} body 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public trainEmbeddingSdapiV1TrainEmbeddingPost(body: object, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).trainEmbeddingSdapiV1TrainEmbeddingPost(body, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Train Hypernetwork
     * @param {object} body 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public trainHypernetworkSdapiV1TrainHypernetworkPost(body: object, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).trainHypernetworkSdapiV1TrainHypernetworkPost(body, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Unloadapi
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public unloadapiSdapiV1UnloadCheckpointPost(options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).unloadapiSdapiV1UnloadCheckpointPost(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Upload File
     * @param {Array<File>} files 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public uploadFileUploadPost(files: Array<File>, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).uploadFileUploadPost(files, options).then((request) => request(this.axios, this.basePath));
    }
}



